<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>lcsim API documentation</title>
    <meta name="description" content="Blazar light curve simulation." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>

  <style type="text/css">
  .codehilite .hll { background-color: #ffffcc }
.codehilite  { background: #f8f8f8; }
.codehilite .c { color: #408080; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #BC7A00 } /* Comment.Preproc */
.codehilite .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #408080; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #408080; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .gr { color: #FF0000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #00A000 } /* Generic.Inserted */
.codehilite .go { color: #888888 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0044DD } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #7D9029 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.codehilite .no { color: #880000 } /* Name.Constant */
.codehilite .nd { color: #AA22FF } /* Name.Decorator */
.codehilite .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #0000FF } /* Name.Function */
.codehilite .nl { color: #A0A000 } /* Name.Label */
.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mb { color: #666666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666666 } /* Literal.Number.Float */
.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #BB6688 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #0000FF } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */
  </style>

  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#lcsim.brokenpowerlaw">brokenpowerlaw</a></li>
    <li class="mono"><a href="#lcsim.kneemodel">kneemodel</a></li>
    <li class="mono"><a href="#lcsim.powerlaw">powerlaw</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#lcsim.ArtificialLightCurve">ArtificialLightCurve</a></span>
        
          
  <ul>
    <li class="mono"><a href="#lcsim.ArtificialLightCurve.__init__">__init__</a></li>
    <li class="mono"><a href="#lcsim.ArtificialLightCurve.add_errors">add_errors</a></li>
    <li class="mono"><a href="#lcsim.ArtificialLightCurve.data">data</a></li>
    <li class="mono"><a href="#lcsim.ArtificialLightCurve.resample">resample</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#lcsim.LightCurveSimulator">LightCurveSimulator</a></span>
        
          
  <ul>
    <li class="mono"><a href="#lcsim.LightCurveSimulator.suggest_time_sampling">suggest_time_sampling</a></li>
    <li class="mono"><a href="#lcsim.LightCurveSimulator.__init__">__init__</a></li>
    <li class="mono"><a href="#lcsim.LightCurveSimulator.adjust_pdf">adjust_pdf</a></li>
    <li class="mono"><a href="#lcsim.LightCurveSimulator.brokenpowerlaw">brokenpowerlaw</a></li>
    <li class="mono"><a href="#lcsim.LightCurveSimulator.get_lcs">get_lcs</a></li>
    <li class="mono"><a href="#lcsim.LightCurveSimulator.kneemodel">kneemodel</a></li>
    <li class="mono"><a href="#lcsim.LightCurveSimulator.multi_logn">multi_logn</a></li>
    <li class="mono"><a href="#lcsim.LightCurveSimulator.powerlaw">powerlaw</a></li>
    <li class="mono"><a href="#lcsim.LightCurveSimulator.set_time_sampling">set_time_sampling</a></li>
    <li class="mono"><a href="#lcsim.LightCurveSimulator.sim_emp">sim_emp</a></li>
    <li class="mono"><a href="#lcsim.LightCurveSimulator.sim_tk">sim_tk</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">lcsim</span> module</h1>
  <p>Blazar light curve simulation.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-lcsim', this);">Show source &equiv;</a></p>
  <div id="source-lcsim" class="source">
    <div class="codehilite"><pre><span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#!/usr/bin/env python</span>
<span class="sd">&quot;&quot;&quot;Blazar light curve simulation.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">ceil</span><span class="p">,</span> <span class="n">exp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">statsmodels.distributions</span> <span class="kn">import</span> <span class="n">ECDF</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Sebastian Kiehlmann&quot;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Sebastian Kiehlmann&quot;</span><span class="p">]</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s2">&quot;GPL&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;2.0&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Sebastian Kiehlmann&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s2">&quot;skiehlmann@mail.de&quot;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s2">&quot;Production&quot;</span>

<span class="c1">#==============================================================================</span>
<span class="c1"># CLASSES</span>
<span class="c1">#==============================================================================</span>

<span class="k">class</span> <span class="nc">ArtificialLightCurve</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Process an artificial light curve.&quot;&quot;&quot;</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">lc_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an instance of ArtificialLightCurve.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        time : np.ndarray</span>
<span class="sd">            Time steps.</span>
<span class="sd">        flux : np.ndarray</span>
<span class="sd">            Flux values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : ArtificialLightCurve-instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span> <span class="o">=</span> <span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_orig</span> <span class="o">=</span> <span class="n">flux</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lc_type</span> <span class="o">=</span> <span class="n">lc_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_total</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_sampling</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span><span class="o">.</span><span class="n">size</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_res</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_res_total</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_res_sampling</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns gereneral information about the simulated data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;Artificial light curve</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Simulation type:        {0:&gt;10s}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lc_type</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Original time sampling: {0:10.3f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_sampling</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Original total time:    {0:10.3f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_total</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span> <span class="o">==</span> <span class="s1">&#39;const&#39;</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Resampled-------------------------</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Time steps:             {0:&gt;10s}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;even&#39;</span><span class="p">)</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Time sampling:          {0:10.3f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">time_res_sampling</span><span class="p">)</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Total time:             {0:10.3f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">time_res_total</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;powerlaw&#39;</span><span class="p">,</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">,</span> <span class="s1">&#39;ecdf&#39;</span><span class="p">,</span> <span class="s1">&#39;specific&#39;</span><span class="p">]:</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Resampled-------------------------</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Time steps:             {0:&gt;10s}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;uneven&#39;</span><span class="p">)</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Distribution:           {0:&gt;10s}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resampled</span><span class="p">)</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Median time sampling:   {0:10.3f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">time_res_sampling</span><span class="p">)</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Total time:             {0:10.3f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">time_res_total</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="o">==</span> <span class="s1">&#39;const&#39;</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Gaussian noise added--------------</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Uncertainties:  {0:&gt;18s}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;homoscedastic&#39;</span><span class="p">)</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Median uncertainty:     {0:10.3f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;specific&#39;</span><span class="p">,</span> <span class="s1">&#39;ecdf&#39;</span><span class="p">,</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">]:</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Gaussian noise added--------------</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Uncertainties:  {0:&gt;18s}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;heteroscedastic&#39;</span><span class="p">)</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Distribution:   {0:&gt;18s}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span><span class="p">)</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Median uncertainty:     {0:10.3f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">text</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_draw_from_powerlaw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">minval</span><span class="p">,</span> <span class="n">maxval</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draws random numbers from a truncated power-law distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        index : float</span>
<span class="sd">            Power-law index.</span>
<span class="sd">        minval : float</span>
<span class="sd">            Lower limit of the distribution.</span>
<span class="sd">        maxval : float</span>
<span class="sd">            Upper limit of the distribution.</span>
<span class="sd">        size : int, default=1</span>
<span class="sd">            Number of random data points to return.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : np.1darray</span>
<span class="sd">            Random numbers.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mf">1.</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">((</span><span class="n">maxval</span><span class="o">**</span><span class="n">index</span> <span class="o">-</span> <span class="n">minval</span><span class="o">**</span><span class="n">index</span><span class="p">)</span> \
                        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="n">minval</span><span class="o">**</span><span class="n">index</span><span class="p">,</span>
                        <span class="mf">1.</span> <span class="o">/</span> <span class="n">index</span><span class="p">)</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_draw_from_ecdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draws random number from an empirical cumulative distribution</span>
<span class="sd">        function (ECDF) defined by given data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        data : np.1darray</span>
<span class="sd">            The data which defines the ECDF.</span>
<span class="sd">        size : int, default=1</span>
<span class="sd">            Number of random data points to return.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : np.1darray</span>
<span class="sd">            Random numbers.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ecdf</span> <span class="o">=</span> <span class="n">ECDF</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">draw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">ecdf</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">draw</span><span class="p">,</span> <span class="n">ecdf</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">ecdf</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_random_timesteps</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">total_time</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="s1">&#39;powerlaw&#39;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">recursion</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates random time data points with time steps following a given</span>
<span class="sd">        distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        total_time : float</span>
<span class="sd">            The total time to cover by the time data points</span>
<span class="sd">        dist : str, default=&#39;powerlaw&#39;</span>
<span class="sd">            Defines the distribution the time steps are drawn from. Choose from</span>
<span class="sd">            truncated &#39;powerlaw&#39;, &#39;lognormal&#39; and &#39;ecdf&#39;. The distribution</span>
<span class="sd">            parameters need to be set accordingly in the &#39;params&#39;.</span>
<span class="sd">        params : list</span>
<span class="sd">            A list of distribution parameters.</span>
<span class="sd">            For &#39;powerlaw&#39; give (1) the power-law index, (2) the lower, and (3)</span>
<span class="sd">            the upper limit of the truncated distribution.</span>
<span class="sd">            For &#39;lognormal&#39; give the distribution (1) mu and (2) sigma.</span>
<span class="sd">            For &#39;ecdf&#39; give an array of time steps (differences between time</span>
<span class="sd">            data points not the time data points!).</span>
<span class="sd">        recursion : int, default=0</span>
<span class="sd">            Do not manually set a value. This parameter is needed internally</span>
<span class="sd">            when the drawn time steps are not enough to cover the targeted</span>
<span class="sd">            total time and a recursion call of the function is necessery.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : np.1darray</span>
<span class="sd">            Random time data points.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># determine number of time steps to create:</span>
        <span class="k">if</span> <span class="n">recursion</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">recursion</span>

        <span class="k">elif</span> <span class="n">dist</span> <span class="o">==</span> <span class="s1">&#39;powerlaw&#39;</span> <span class="ow">and</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">2.</span><span class="p">:</span>
            <span class="n">mean_sampling</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> \
                             <span class="o">-</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> \
                             <span class="o">/</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> \
                                <span class="o">-</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> \
                             <span class="o">*</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">total_time</span> <span class="o">/</span> <span class="n">mean_sampling</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">mean_sampling</span>

        <span class="k">elif</span> <span class="n">dist</span><span class="o">==</span><span class="s1">&#39;lognormal&#39;</span><span class="p">:</span>
            <span class="n">mean_sampling</span> <span class="o">=</span> <span class="n">exp</span><span class="p">((</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">total_time</span> <span class="o">/</span> <span class="n">mean_sampling</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">mean_sampling</span>

        <span class="k">elif</span> <span class="n">dist</span><span class="o">==</span><span class="s1">&#39;ecdf&#39;</span><span class="p">:</span>
            <span class="n">mean_sampling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">total_time</span> <span class="o">/</span> <span class="n">mean_sampling</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">mean_sampling</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">100</span>

        <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">10</span>

        <span class="c1"># create random time steps:</span>
        <span class="k">if</span> <span class="n">dist</span><span class="o">==</span><span class="s1">&#39;powerlaw&#39;</span><span class="p">:</span>
            <span class="n">steps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_draw_from_powerlaw</span><span class="p">(</span>
                    <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">dist</span><span class="o">==</span><span class="s1">&#39;lognormal&#39;</span><span class="p">:</span>
            <span class="n">steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">lognormal</span><span class="p">(</span>
                    <span class="n">mean</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigma</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">dist</span><span class="o">==</span><span class="s1">&#39;ecdf&#39;</span><span class="p">:</span>
            <span class="n">steps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_draw_from_ecdf</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Distribution type &#39;{0:s}&#39; is not supported. Either set &quot;</span> \
                    <span class="s2">&quot;to &#39;powerlaw&#39;, &#39;lognormal&#39;, or &#39;ecdf&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dist</span><span class="p">))</span>

        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

        <span class="c1"># recursion, if time steps do not cover total time:</span>
        <span class="k">if</span> <span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">total_time</span><span class="p">:</span>
           <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">total_time</span><span class="p">)</span> <span class="o">*</span> <span class="n">size</span><span class="p">))</span>
           <span class="n">more</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_timesteps</span><span class="p">(</span>
                   <span class="n">total_time</span><span class="o">-</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dist</span><span class="o">=</span><span class="n">dist</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
                   <span class="n">recursion</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
           <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">time</span><span class="p">,</span> <span class="n">more</span><span class="o">+</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">recursion</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">time</span>

        <span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="n">time</span><span class="o">&lt;=</span><span class="n">total_time</span><span class="p">]</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">time</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">time</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_steps</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resample the artificial light curve.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        time_steps : float, numpy.ndarray, or str</span>
<span class="sd">            See notes for details.</span>
<span class="sd">        params : list or numpy.ndarray, default=None</span>
<span class="sd">            See notes for details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method provides several options to resample the artificial data to</span>
<span class="sd">        an even or uneven time grid:</span>
<span class="sd">        1. Provide a float for &#39;time_steps&#39; to resample to an even time grid.</span>
<span class="sd">        2. Provide a numpy.ndarray for &#39;time steps&#39;. The light curve will be</span>
<span class="sd">           resampled to these time stamps. The light curve will be cut off,</span>
<span class="sd">           when the provided array exceeds the total time of the simulated</span>
<span class="sd">           data. Note that the simulated data starts at time 0.</span>
<span class="sd">        3. Set &#39;time_steps&#39; to &#39;ecdf&#39; and provide a numpy.ndarray of time</span>
<span class="sd">           stamps to &#39;params&#39;. The method will calculate the ECDF of time steps</span>
<span class="sd">           (i.e. time differences) between the provided time data and then</span>
<span class="sd">           randomly draw time steps from the ECDF to construct a new series of</span>
<span class="sd">           time stamps.</span>
<span class="sd">        4. Set &#39;time_steps&#39; to &#39;powerlaw&#39; and provide a list of three</span>
<span class="sd">           parameters to &#39;param&#39;: (1) the power-law index, (2) the lower, and</span>
<span class="sd">           (3) the upper limit of the truncated distribution.</span>
<span class="sd">           Time steps will be randomly drawn from this distribution to</span>
<span class="sd">           construct a new series of time stamps.</span>
<span class="sd">        5. Set &#39;time_steps&#39; to &#39;lognormal&#39; and provide a list of two parameters</span>
<span class="sd">           to &#39;param&#39;: (1) mu and (2) sigma.</span>
<span class="sd">           Time steps will be randomly drawn from this distribution to</span>
<span class="sd">           construct a new series of time stamps.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># even time sampling:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_steps</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="c1"># time step is shorter than original time sampling:</span>
            <span class="k">if</span> <span class="n">time_steps</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_sampling</span><span class="p">:</span>
                <span class="k">print</span> <span class="s1">&#39;Requested time step is shorter or equal to original &#39;</span> \
                      <span class="s1">&#39;sampling. resample() aborted.&#39;</span>
                <span class="k">return</span> <span class="bp">False</span>

            <span class="c1"># time step is a multiple of the original sampling:</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">time_steps</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_sampling</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ratio</span><span class="p">)</span> <span class="o">%</span> <span class="mf">1.</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span><span class="p">[::</span><span class="n">n</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flux_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_orig</span><span class="p">[::</span><span class="n">n</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span> <span class="o">=</span> <span class="s1">&#39;const&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_res_total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_res_sampling</span> <span class="o">=</span> <span class="n">time_steps</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="o">.</span><span class="n">size</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="k">print</span> <span class="s1">&#39;Note: resampling removed the error simulation.&#39;</span>

                <span class="k">return</span> <span class="bp">True</span>

            <span class="c1"># time step requires interpolation:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_total</span><span class="p">,</span> <span class="n">time_steps</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span> <span class="o">=</span> <span class="s1">&#39;const&#39;</span>

        <span class="c1"># resample to specified time steps:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_steps</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># check that time steps are within total time:</span>
            <span class="n">time_steps</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">time_steps</span><span class="p">)</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="n">time_steps</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_total</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span> <span class="o">=</span> <span class="n">time_steps</span><span class="p">[</span><span class="n">sel</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span> <span class="o">=</span> <span class="s1">&#39;specific&#39;</span>

        <span class="c1"># draw time steps from ECDF of time steps:</span>
        <span class="k">elif</span> <span class="n">time_steps</span> <span class="o">==</span> <span class="s1">&#39;ecdf&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_timesteps</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_total</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="s1">&#39;ecdf&#39;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span> <span class="o">=</span> <span class="s1">&#39;ecdf&#39;</span>

        <span class="c1"># draw time steps from powerlaw or log-normal distribution:</span>
        <span class="k">elif</span> <span class="n">time_steps</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;powerlaw&#39;</span><span class="p">,</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_timesteps</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_total</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="n">time_steps</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span> <span class="o">=</span> <span class="n">time_steps</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported input for &#39;time_steps&#39;.&quot;</span><span class="p">)</span>

        <span class="c1"># interpolate data:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_orig</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_res_total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">time_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_res_sampling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">time_diff</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="o">.</span><span class="n">size</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">add_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uncertainties</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add Gaussian noise to the artificial light curve.</span>

<span class="sd">        An error term is drawn randomly for each data point from a Gaussian</span>
<span class="sd">        distribution and added to the simulated data:</span>

<span class="sd">        .. math::</span>
<span class="sd">            f_{\mathrm{sim},i} \\rightarrow f_{\mathrm{sim},i} + f_{\mathrm{err},i}</span>

<span class="sd">        with</span>


<span class="sd">        .. math::</span>
<span class="sd">            f_{\mathrm{err},i} \sim \\mathcal{N}(0, \sigma_i)</span>

<span class="sd">        The noise scale sigma_i can be be the same for all data points or vary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        uncertainties : float, numpy.ndarray, or str</span>
<span class="sd">            See notes for details.</span>
<span class="sd">        params : list or numpy.ndarray, default=None</span>
<span class="sd">            See notes for details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method provides several options to add homoscedastic and</span>
<span class="sd">        heteroscedastic error to the artificial data:</span>
<span class="sd">        1. Provide a float for &#39;uncertainties&#39; to use the same uncertainty</span>
<span class="sd">           scale for each data point (homoscedasticity).</span>
<span class="sd">        2. Provide a numpy.ndarray for &#39;uncertainties&#39;. The values in the array</span>
<span class="sd">           are used as the uncertainty scales for each corresponding data</span>
<span class="sd">           point. Note that the length of &#39;uncertainties&#39; needs to match the</span>
<span class="sd">           length of the simulated light curve.</span>
<span class="sd">        3. Set &#39;uncertainties&#39; to &#39;ecdf&#39; and provide a numpy.ndarray of</span>
<span class="sd">           uncertainties to &#39;params&#39;. The method will calculate the ECDF of the</span>
<span class="sd">           uncertainties and then randomly draw uncertainties from the ECDF.</span>
<span class="sd">        4. Set &#39;uncertainties&#39; to &#39;lognormal&#39; and provide a list of two</span>
<span class="sd">           parameters to &#39;param&#39;: (1) mu and (2) sigma.</span>
<span class="sd">           Uncertainties are randomly drawn from this distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># homoscedastic uncertainties:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uncertainties</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="n">uncertainties</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="o">=</span> <span class="s1">&#39;const&#39;</span>

        <span class="c1"># specific uncertainties:</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uncertainties</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="n">uncertainties</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span> <span class="o">=</span> <span class="n">uncertainties</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="o">=</span> <span class="s1">&#39;specific&#39;</span>

        <span class="c1"># draw uncertainties from ECDF of uncertainties:</span>
        <span class="k">elif</span> <span class="n">uncertainties</span> <span class="o">==</span> <span class="s1">&#39;ecdf&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_draw_from_ecdf</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="o">=</span> <span class="s1">&#39;ecdf&#39;</span>

        <span class="c1"># draw uncertainties from log-normal distribution:</span>
        <span class="k">elif</span> <span class="n">uncertainties</span> <span class="o">==</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">lognormal</span><span class="p">(</span>
                    <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="o">=</span> <span class="s1">&#39;lognormal&#39;</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported input for &#39;uncertainties&#39;.&quot;</span><span class="p">)</span>

        <span class="c1"># apply errors:</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_res</span> <span class="o">+</span> <span class="n">err</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_orig</span> <span class="o">+</span> <span class="n">err</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">get_all</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the simulated light curve data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        get_all : bool, default=False</span>
<span class="sd">            As default returns only the final light curve data, i.e. the</span>
<span class="sd">            resampled and/or noise-added light curve.</span>
<span class="sd">            If True, returns all data including the original sampling.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : dict</span>
<span class="sd">            Simulated light curve data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># return all light curves (original, resampled, errors added):</span>
        <span class="k">if</span> <span class="n">get_all</span><span class="p">:</span>
            <span class="c1"># add original light curve:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;time_orig&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span><span class="p">,</span>
                    <span class="s1">&#39;flux_orig&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_orig</span><span class="p">}</span>

            <span class="c1"># add resampled light curve (if available):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="s1">&#39;time_res&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span>
                <span class="n">results</span><span class="p">[</span><span class="s1">&#39;flux_res&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_res</span>

            <span class="c1"># add error-added light curve (if available):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="s1">&#39;flux_err&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span>
                <span class="n">results</span><span class="p">[</span><span class="s1">&#39;flux_unc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span>

        <span class="c1"># return final light curve (resampled and error-added):</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">,</span>
                    <span class="s1">&#39;flux&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span><span class="p">,</span>
                    <span class="s1">&#39;flux_unc&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span><span class="p">}</span>

        <span class="c1"># return final light curve (error-added):</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span><span class="p">,</span>
                    <span class="s1">&#39;flux&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span><span class="p">,</span>
                    <span class="s1">&#39;flux_unc&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span><span class="p">}</span>

        <span class="c1"># return final light curve (resampled):</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">,</span>
                    <span class="s1">&#39;flux&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_res</span><span class="p">}</span>

        <span class="c1"># return final light curve (original):</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span><span class="p">,</span>
                    <span class="s1">&#39;flux&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_orig</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">results</span>

<span class="c1">#==============================================================================</span>

<span class="k">class</span> <span class="nc">LightCurveSimulator</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Simulate blazar light curves as a random noise process.&quot;&quot;&quot;</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_total</span><span class="p">,</span> <span class="n">time_sampling</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an instance of LightCurveSimulator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        time_total : float</span>
<span class="sd">            Set the total time for the simulated data.</span>
<span class="sd">        time_sampling : float</span>
<span class="sd">            Set the time sampling for the simulated data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : LightCurveSimulator-instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">time_total</span> <span class="o">=</span> <span class="n">time_total</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_sampling</span> <span class="o">=</span> <span class="n">time_sampling</span>

        <span class="c1"># number of data points of the simulated data:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">time_total</span> <span class="o">/</span> <span class="n">time_sampling</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># create data time steps:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_timesteps</span><span class="p">()</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">set_time_sampling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_total</span><span class="p">,</span> <span class="n">time_sampling</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an instance of LightCurveSimulator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        time_total : float</span>
<span class="sd">            Set the total time for the simulated data.</span>
<span class="sd">        time_sampling : float</span>
<span class="sd">            Set the time sampling for the simulated data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">time_total</span> <span class="o">=</span> <span class="n">time_total</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_sampling</span> <span class="o">=</span> <span class="n">time_sampling</span>

        <span class="c1"># number of data points of the simulated data:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">time_total</span> <span class="o">/</span> <span class="n">time_sampling</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># create data time steps:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_timesteps</span><span class="p">()</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">suggest_time_sampling</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">10.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Suggests a total time and time sampling for simulated data, based on</span>
<span class="sd">        input time data. The total time is increased by a given factor, the</span>
<span class="sd">        time sampling reduced by the same factor, to include low and high</span>
<span class="sd">        frequency power in the simulated noise process.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        time : 1darray</span>
<span class="sd">            Time series.</span>
<span class="sd">        average : string, default=&#39;median&#39;</span>
<span class="sd">            Choose average type (&#39;median&#39; or &#39;mean&#39;) for suggested sampling.</span>
<span class="sd">        factor : float, default=10.</span>
<span class="sd">            The suggested total time and sampling are modified by this factor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out, out : float, float</span>
<span class="sd">            Suggested (minimum) total time and (maximum) sampling rate.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">total_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">deltat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">sampling_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">deltat</span><span class="p">)</span>
        <span class="n">sampling_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">deltat</span><span class="p">)</span>
        <span class="n">sampling_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">deltat</span><span class="p">)</span>
        <span class="n">sampling_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">deltat</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">average</span><span class="o">==</span><span class="s1">&#39;median&#39;</span><span class="p">:</span>
            <span class="n">sim_sampling</span> <span class="o">=</span> <span class="n">sampling_median</span> <span class="o">/</span> <span class="n">factor</span>
        <span class="k">elif</span> <span class="n">average</span><span class="o">==</span><span class="s1">&#39;mean&#39;</span><span class="p">:</span>
            <span class="n">sim_sampling</span> <span class="o">=</span> <span class="n">sampling_mean</span> <span class="o">/</span> <span class="n">factor</span>
        <span class="n">sim_total</span> <span class="o">=</span> <span class="n">total_time</span> <span class="o">*</span> <span class="n">factor</span>

        <span class="k">print</span> <span class="s1">&#39;Total time:         {0:8.3f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">total_time</span><span class="p">)</span>
        <span class="k">print</span> <span class="s1">&#39;Min. sampling:      {0:8.3f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampling_min</span><span class="p">)</span>
        <span class="k">print</span> <span class="s1">&#39;Max. sampling:      {0:8.3f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampling_max</span><span class="p">)</span>
        <span class="k">print</span> <span class="s1">&#39;Mean sampling:      {0:8.3f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampling_mean</span><span class="p">)</span>
        <span class="k">print</span> <span class="s1">&#39;Median sampling:    {0:8.3f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampling_median</span><span class="p">)</span>
        <span class="k">print</span> <span class="s1">&#39;Suggested&#39;</span>
        <span class="k">print</span> <span class="s1">&#39;Maximum sampling:   {0:8.3f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sim_sampling</span><span class="p">)</span>
        <span class="k">print</span> <span class="s1">&#39;Minimum total time: {0:8.3f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sim_total</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sim_total</span><span class="p">,</span> <span class="n">sim_sampling</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_create_timesteps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates time steps based on total time and time sampling.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># adjust total time:</span>
        <span class="n">time_total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_sampling</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">time_total</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndp</span><span class="p">)</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">powerlaw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an array of amplitudes following a power-law over the input</span>
<span class="sd">        frequencies.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        frequencies : 1darray</span>
<span class="sd">            Frequencies for which to calculate the power-law in arbitrary</span>
<span class="sd">            units.</span>
<span class="sd">        index : float, default=1.</span>
<span class="sd">            Power-law index.</span>
<span class="sd">        amplitude : float, default=10.</span>
<span class="sd">            Power-law amplitude at &#39;frequency&#39; in arbitrary unit.</span>
<span class="sd">        frequency : float, default=0.1</span>
<span class="sd">            Frequency for the given &#39;amplitude&#39; in same unit as &#39;frequencies&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : 1darray</span>
<span class="sd">            Array of same length as input &#39;frequencies&#39;.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Can be used as a generic shape for the power spectrum of a simulated</span>
<span class="sd">        light curve.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">/</span> <span class="n">frequency</span><span class="p">,</span> <span class="o">-</span><span class="n">index</span><span class="p">)</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">kneemodel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an array of amplitudes following a constant profile that</span>
<span class="sd">        changes into a power-law around a given frequency.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        frequencies : 1darray</span>
<span class="sd">            Frequencies for which to calculate the power-law in arbitrary</span>
<span class="sd">            units.</span>
<span class="sd">        index : float, default=1.</span>
<span class="sd">            Power-law index.</span>
<span class="sd">        amplitude : float, default=10.</span>
<span class="sd">            Constant amplitude at frequencies below &#39;frequency&#39; in arbitrary</span>
<span class="sd">            unit.</span>
<span class="sd">        frequency : float, default=0.1</span>
<span class="sd">            Frequency  in same unit as &#39;frequencies&#39; at which profile changes</span>
<span class="sd">            into a power-law.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : 1darray</span>
<span class="sd">            Array of same length as input &#39;frequencies&#39;.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Can be used as a generic shape for the power spectrum of a simulated</span>
<span class="sd">        light curve.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">/</span> <span class="n">frequency</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                                    <span class="o">-</span><span class="n">index</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">brokenpowerlaw</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="n">index_lo</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">index_hi</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span>
            <span class="n">frequency</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an array of amplitudes following a broken power-law.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        frequencies : array</span>
<span class="sd">            Frequencies for which to calculate the power-law in arbitrary units.</span>
<span class="sd">        index_hi : float, default=2.</span>
<span class="sd">            Power-law index at frequencies lower than &#39;frequency&#39;.</span>
<span class="sd">        index_lo : float, default=1.</span>
<span class="sd">            Power-law index at frequencies higher than &#39;frequency&#39;.</span>
<span class="sd">        frequency : float, default=0.1</span>
<span class="sd">            Frequency of the power-law break in same unit as &#39;frequencies&#39;.</span>
<span class="sd">        amplitude : float, default=10.</span>
<span class="sd">            Amplitude at &#39;frequency&#39; in arbitrary unit.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">            Array of same length as input &#39;frequencies&#39;.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Can be used as a generic shape for the power spectrum of a simulated</span>
<span class="sd">        light curve.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">frequencies</span> <span class="o">&gt;</span> <span class="n">frequency</span><span class="p">,</span>
                <span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">/</span> <span class="n">frequency</span><span class="p">,</span> <span class="o">-</span><span class="n">index_hi</span><span class="p">),</span>
                <span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">/</span> <span class="n">frequency</span><span class="p">,</span> <span class="o">-</span><span class="n">index_lo</span><span class="p">))</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">multi_logn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multi-component log-normal function.</span>

<span class="sd">        Returns the function values at position x.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------</span>
<span class="sd">        x : float or np.ndarray</span>
<span class="sd">            Function is evaluated at these positions.</span>
<span class="sd">        params : list</span>
<span class="sd">            Function parameters. For each log-normal component three</span>
<span class="sd">            parameters: peak position, peak amplitude, peak width. For multiple</span>
<span class="sd">            components append tripplets of these parameters (e.g.</span>
<span class="sd">            [pos1, amp1, wid1, pos2, amp2, wid2]).</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : float or np.ndarray</span>
<span class="sd">            Function evaluated at x.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Can be used as a generic shape for the probability density of a</span>
<span class="sd">        simulated light curve.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">),</span> <span class="mi">3</span><span class="p">):</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">amp</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">wid</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">amp</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span> <span class="o">/</span> <span class="n">wid</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">y</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_draw_from_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draws random number from a function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        func : function</span>
<span class="sd">            A function to draw random mumbers from.</span>
<span class="sd">        params : list</span>
<span class="sd">            The parameters of the PDF.</span>
<span class="sd">        x_min : float</span>
<span class="sd">            The minimum value to draw.</span>
<span class="sd">        x_min : float</span>
<span class="sd">            The maximum value to draw.</span>
<span class="sd">        size : int, default=1</span>
<span class="sd">            Number of random data points to return.</span>
<span class="sd">        seed : int, default=False</span>
<span class="sd">            Sets a seed for the random generator to get a reproducable result.</span>
<span class="sd">            For testing only.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : np.1darray</span>
<span class="sd">            Random numbers.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Can be used to draw random numbers from a probability density function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="n">pdf</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>
        <span class="n">cdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>
        <span class="n">cdf</span> <span class="o">/=</span> <span class="n">cdf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">seed</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">rand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">rand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">rand</span><span class="p">,</span> <span class="n">cdf</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rand</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_sim_tk</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">time_total</span><span class="p">,</span> <span class="n">time_sampling</span><span class="p">,</span> <span class="n">spec_shape</span><span class="p">,</span> <span class="n">spec_args</span><span class="p">,</span>
            <span class="n">seed</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function that is called by self.sim_tk().</span>

<span class="sd">        This function implements the Timmer &amp; Koenig, 1995 [1] algorithm for</span>
<span class="sd">        producing a single artificial light curve. See docstring of</span>
<span class="sd">        self.sim_tk() for details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        time_total : float</span>
<span class="sd">            Length of the simulation in arbitrary time unit.</span>
<span class="sd">        time_sampling : float</span>
<span class="sd">            Length of the sampling interval in same unit as &#39;time&#39;.</span>
<span class="sd">        spec_shape : func</span>
<span class="sd">            Function that takes an array of frequencies and &#39;spec_args&#39; as</span>
<span class="sd">            input and calculates a spectrum for those frequencies.</span>
<span class="sd">        spec_args : list</span>
<span class="sd">            Function arguments to &#39;spec_shape&#39;.</span>
<span class="sd">        seed : int, default=False</span>
<span class="sd">            Sets a seed for the random generator to get a reproducable result.</span>
<span class="sd">            For testing only.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : numpy.ndarray</span>
<span class="sd">            Simulated light curve following a random noise process with the</span>
<span class="sd">            input power spectrum.</span>

<span class="sd">        References</span>
<span class="sd">        -----</span>
<span class="sd">        [1] Timmer and Koenig, 1995, &#39;On generating power law noise&#39;, A&amp;A, 300,</span>
<span class="sd">            707</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get number of data points:</span>
        <span class="n">ndp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">time_total</span> <span class="o">/</span> <span class="n">time_sampling</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># set spectrum:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">ndp</span><span class="p">,</span> <span class="n">time_sampling</span><span class="p">)</span>
        <span class="n">freq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="n">spec_shape</span><span class="p">(</span><span class="n">freq</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="o">*</span><span class="n">spec_args</span><span class="p">)</span>
        <span class="n">spectrum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">del</span> <span class="n">freq</span>

        <span class="c1"># random (complex) Fourier coefficients for inverse Fourier transform:</span>
        <span class="k">if</span> <span class="n">seed</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="c1"># if N is even the Nyquist frequency is real:</span>
        <span class="k">if</span> <span class="n">ndp</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">coef</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c1"># complex coefficients:</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">coef</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1j</span> <span class="o">*</span> <span class="n">coef</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># scale coefficients with spectrum:</span>
        <span class="c1">#coef *= np.sqrt(0.5 * spectrum) # this is how it is defined in T&amp;K95</span>
        <span class="c1">#coef *= np.sqrt(0.5 * spectrum * ndp / sampling) # this is what I</span>
        <span class="c1"># used in PhD thesis</span>
        <span class="n">coef</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">spectrum</span> <span class="o">*</span> <span class="n">ndp</span><span class="p">)</span> <span class="c1"># this is what works to get</span>
        <span class="c1"># correct PSD slope, see argument in PhD notebook</span>
        <span class="c1"># 1.2_AmplitudeProblem.ipynb</span>
        <span class="n">coef</span> <span class="o">*=</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="n">spec_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">2.5</span><span class="p">)</span> <span class="c1"># this is an empirical scaling factor</span>
        <span class="c1"># to get the correct amplitude (approximately; would be better to</span>
        <span class="c1"># understand where this is coming from)</span>

        <span class="c1"># inverse Fourier transform:</span>
        <span class="n">lightcurve</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">coef</span><span class="p">,</span> <span class="n">ndp</span><span class="p">)</span>

        <span class="c1"># normalize to zero mean:</span>
        <span class="n">lightcurve</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">lightcurve</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lightcurve</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">sim_tk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec_shape</span><span class="p">,</span> <span class="n">spec_args</span><span class="p">,</span> <span class="n">nlcs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Simulates one/multiple equally sampled light curve(s) following a</span>
<span class="sd">        random noise process with given a spectral shape of the power spectral</span>
<span class="sd">        density [1].</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        spec_shape : func</span>
<span class="sd">            Function that takes an array of frequencies and &#39;spec_args&#39; as</span>
<span class="sd">            input and calculates a spectrum for those frequencies.</span>
<span class="sd">        spec_args : list</span>
<span class="sd">            Function arguments to &#39;spec_shape&#39;.</span>
<span class="sd">        nlcs : int, default=1</span>
<span class="sd">            Set the number of light curves that are produced. See notes below.</span>
<span class="sd">        seed : int, default=False</span>
<span class="sd">            Sets a seed for the random generator to get a reproducable result.</span>
<span class="sd">            For testing only.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The method will initially produce one long light curve with a total</span>
<span class="sd">        time N times longer than the final total time, where N is set by</span>
<span class="sd">        &#39;nlcs&#39;. This long light curve is then split into N individual pieces.</span>
<span class="sd">        Producing one initial long light curves means that power at frequencies</span>
<span class="sd">        N times lower than the final total time is included in the noise</span>
<span class="sd">        process. Setting ncls&gt;1 allows to include low-frequency power.</span>

<span class="sd">        References</span>
<span class="sd">        -----</span>
<span class="sd">        [1] Timmer and Koenig, 1995, &#39;On generating power law noise&#39;, A&amp;A, 300,</span>
<span class="sd">            707</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get total time of long light curve:</span>
        <span class="n">time_total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_sampling</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndp</span> <span class="o">*</span> <span class="n">nlcs</span>

        <span class="c1"># simulate long lightcurve:</span>
        <span class="n">lightcurve</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sim_tk</span><span class="p">(</span>
                <span class="n">time_total</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_sampling</span><span class="p">,</span> <span class="n">spec_shape</span><span class="p">,</span> <span class="n">spec_args</span><span class="p">,</span>
                <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">lightcurve</span> <span class="o">=</span> <span class="n">lightcurve</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># one light curve: store final data:</span>
        <span class="k">if</span> <span class="n">nlcs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span> <span class="o">=</span> <span class="p">[</span><span class="n">lightcurve</span><span class="p">]</span>

        <span class="c1"># multiple light curves: reshape to short light curves:</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">nlcs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndp</span><span class="p">)</span>
            <span class="n">lightcurves</span> <span class="o">=</span> <span class="n">lightcurve</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">ndp</span><span class="o">*</span><span class="n">nlcs</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">lc</span> <span class="ow">in</span> <span class="n">lightcurves</span><span class="p">:</span>
                <span class="c1"># normalize to zero mean:</span>
                <span class="n">lc</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lc_type</span> <span class="o">=</span> <span class="s1">&#39;TK&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lc_scale</span> <span class="o">=</span> <span class="s1">&#39;None&#39;</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_adjust_pdf</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">lightcurve</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">pdf_params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pdf_range</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">keep_non_converged</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function that is called by self.adjust_pdf().</span>

<span class="sd">        This function implements the Emmanoulopoulos et al, 2013 [1] algorithm</span>
<span class="sd">        for changing the PDF of a light curve while maintaining its PSD. See</span>
<span class="sd">        docstring of self.adjust_pdf() for details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        lightcurve : numpy.ndarray</span>
<span class="sd">            Flux density data of an evenly sampled light curve.</span>
<span class="sd">        pdf : numpy.ndarray or callable</span>
<span class="sd">            When providing flux data in a numpy.array the method will calculate</span>
<span class="sd">            an ECDF of the input data and draw random flux values from that</span>
<span class="sd">            ECDF.</span>
<span class="sd">            When providing a callable function the method will use that</span>
<span class="sd">            function to draw random flux values. Parameters for the function</span>
<span class="sd">            need to be provided in &#39;pdf_params&#39;</span>
<span class="sd">        pdf_params : list, default=None</span>
<span class="sd">            When a callable function is given to &#39;pdf&#39;, corresponding</span>
<span class="sd">            parameters need to be given to &#39;pdf_params&#39;.</span>
<span class="sd">        pdf_range : list</span>
<span class="sd">            List of two elements. Random flux values will be drawn from the</span>
<span class="sd">            given PDF between the two limits provided by &#39;pdf_range&#39;. Required</span>
<span class="sd">            only when a callable function is given to &#39;pdf&#39;. Does not have an</span>
<span class="sd">            effect, when a numpy.ndarray is given to &#39;pdf&#39;.</span>
<span class="sd">        iterations : int, default=100</span>
<span class="sd">            The algorithm [1] is iterative. This value sets a maximum number of</span>
<span class="sd">            iterations to avoid infinite loops.</span>
<span class="sd">        keep_non_converged : bool or str, default=False</span>
<span class="sd">            If True the result is returned even if the algorithm [1] did not</span>
<span class="sd">            converge.</span>
<span class="sd">            If False and the algorithm [1] did not converge, False is returned.</span>
<span class="sd">            If set to &#39;ask&#39;, a notification is written asking how to proceed.</span>
<span class="sd">        threshold : float, default=0.01</span>
<span class="sd">            Defines when the algorithm [1] is considered as converged.</span>
<span class="sd">            Iterations are stopped when maximum difference between the current</span>
<span class="sd">            and the previous light curve does not exceed this &#39;threshold&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : numpy.ndarray</span>
<span class="sd">            Simulated light curve with the target PDF.</span>

<span class="sd">        References</span>
<span class="sd">        -----</span>
<span class="sd">        [1] Emmanoulopoulos et al, 2013, MNRAS, 433, 907</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># discrete Fourier transform:</span>
        <span class="n">dft_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">lightcurve</span><span class="p">)</span>
        <span class="n">ampl_adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">dft_norm</span><span class="p">)</span>

        <span class="c1"># create artificial light curve based on ECDF of input data:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">ecdf</span> <span class="o">=</span> <span class="n">ECDF</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>
            <span class="n">lc_sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">ecdf</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ndp</span><span class="p">),</span>
                               <span class="n">ecdf</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">ecdf</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># or create artificial light curve based on model PDF:</span>
        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">pdf</span><span class="p">):</span>
            <span class="n">lc_sim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_draw_from_func</span><span class="p">(</span>
                    <span class="n">pdf</span><span class="p">,</span> <span class="n">pdf_params</span><span class="p">,</span> <span class="n">pdf_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pdf_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ndp</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;&#39;pdf&#39; needs to be a np.ndarray or a function.&quot;</span><span class="p">)</span>

        <span class="c1"># iteration:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
            <span class="c1"># calculate DFT, amplitudes:</span>
            <span class="n">dft_sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">lc_sim</span><span class="p">)</span>
            <span class="n">ampl_sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">dft_sim</span><span class="p">)</span>

            <span class="c1"># spectral adjustment:</span>
            <span class="n">dft_adj</span> <span class="o">=</span> <span class="n">dft_sim</span> <span class="o">/</span> <span class="n">ampl_sim</span> <span class="o">*</span> <span class="n">ampl_adj</span>
            <span class="n">lc_adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">dft_adj</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ndp</span><span class="p">)</span>

            <span class="c1"># amplitude adjustment:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">lc_adj</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">lc_sim</span><span class="p">)</span>
            <span class="n">lc_adj</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">lc_sim</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>

            <span class="c1"># check if process converged:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">lc_adj</span> <span class="o">-</span><span class="n">lc_sim</span><span class="p">)</span> <span class="o">/</span> <span class="n">lc_sim</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lc_sim</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">lc_adj</span><span class="p">)</span>

        <span class="c1"># no convergence reached:</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ask what to do:</span>
            <span class="k">if</span> <span class="n">keep_non_converged</span> <span class="o">==</span> <span class="s1">&#39;ask&#39;</span><span class="p">:</span>
                <span class="n">inp</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">(</span>
                        <span class="s1">&#39;No convergence reached within {0:d} iterations. &#39;</span> \
                        <span class="s1">&#39;Keep (y), throw away (n), or try again (r)?&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">iterations</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">inp</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="n">inp</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>
                    <span class="n">lc_sim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjust_pdf</span><span class="p">(</span>
                            <span class="n">lightcurve</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">pdf_params</span><span class="o">=</span><span class="n">pdf_params</span><span class="p">,</span>
                            <span class="n">pdf_range</span><span class="o">=</span><span class="n">pdf_range</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span>
                            <span class="n">keep_non_converged</span><span class="o">=</span><span class="n">keep_non_converged</span><span class="p">,</span>
                            <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lc_sim</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="c1"># keep result anyway:</span>
            <span class="k">elif</span> <span class="n">keep_non_converged</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="c1"># return False:</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lc_sim</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">return</span> <span class="n">lc_sim</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">adjust_pdf</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">pdf_params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pdf_range</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
            <span class="n">keep_non_converged</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change the PDF of all simulated light curves to a target PDF.</span>

<span class="sd">        This method implements the Emmanoulopoulos et al, 2013 [1] algorithm</span>
<span class="sd">        for changing the PDF of a light curve while maintaining its PSD. This</span>
<span class="sd">        routine is automatically applied to all simulated light curves stored</span>
<span class="sd">        in the an LightCurveSimulator-instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        pdf : numpy.ndarray or callable</span>
<span class="sd">            When providing flux data in a numpy.array the method will calculate</span>
<span class="sd">            an ECDF of the input data and draw random flux values from that</span>
<span class="sd">            ECDF.</span>
<span class="sd">            When providing a callable function the method will use that</span>
<span class="sd">            function to draw random flux values. Parameters for the function</span>
<span class="sd">            need to be provided in &#39;pdf_params&#39;</span>
<span class="sd">        pdf_params : list, default=None</span>
<span class="sd">            When a callable function is given to &#39;pdf&#39;, corresponding</span>
<span class="sd">            parameters need to be given to &#39;pdf_params&#39;.</span>
<span class="sd">        pdf_range : list</span>
<span class="sd">            List of two elements. Random flux values will be drawn from the</span>
<span class="sd">            given PDF between the two limits provided by &#39;pdf_range&#39;. Required</span>
<span class="sd">            only when a callable function is given to &#39;pdf&#39;. Does not have an</span>
<span class="sd">            effect, when a numpy.ndarray is given to &#39;pdf&#39;.</span>
<span class="sd">        iterations : int, default=100</span>
<span class="sd">            The algorithm [1] is iterative. This value sets a maximum number of</span>
<span class="sd">            iterations to avoid infinite loops.</span>
<span class="sd">        keep_non_converged : bool or str, default=False</span>
<span class="sd">            If True the result is returned even if the algorithm [1] did not</span>
<span class="sd">            converge.</span>
<span class="sd">            If False and the algorithm [1] did not converge, False is returned.</span>
<span class="sd">            If set to &#39;ask&#39;, a notification is written asking how to proceed.</span>
<span class="sd">        threshold : float, default=0.01</span>
<span class="sd">            Defines when the algorithm [1] is considered as converged.</span>
<span class="sd">            Iterations are stopped when maximum difference between the current</span>
<span class="sd">            and the previous light curve does not exceed this &#39;threshold&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        None</span>

<span class="sd">        References</span>
<span class="sd">        -----</span>
<span class="sd">        [1] Emmanoulopoulos et al, 2013, MNRAS, 433, 907</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check that the PDFs have not been adjusted yet:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lc_type</span> <span class="o">==</span> <span class="s1">&#39;EMP&#39;</span><span class="p">:</span>
            <span class="k">print</span> <span class="s1">&#39;Light curve PDFs have already been adjusted. &#39;</span> \
                  <span class="s1">&#39;adjust_pdf() aborted!&#39;</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c1"># iterate through light curves:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span><span class="p">):</span>
            <span class="n">lc_adj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjust_pdf</span><span class="p">(</span>
                    <span class="n">lc</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">pdf_params</span><span class="o">=</span><span class="n">pdf_params</span><span class="p">,</span> <span class="n">pdf_range</span><span class="o">=</span><span class="n">pdf_range</span><span class="p">,</span>
                    <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span>
                    <span class="n">keep_non_converged</span><span class="o">=</span><span class="n">keep_non_converged</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lc_adj</span>

        <span class="c1"># remove non-converged light curves:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span> <span class="o">=</span> <span class="p">[</span><span class="n">lc</span> <span class="k">for</span> <span class="n">lc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span> <span class="k">if</span> <span class="n">lc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lc_type</span> <span class="o">=</span> <span class="s1">&#39;EMP&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">ECDF</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lc_scale</span> <span class="o">=</span> <span class="s1">&#39;ECDF&#39;</span>
        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">pdf</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lc_scale</span> <span class="o">=</span> <span class="s1">&#39;PDF&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lc_scale</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">sim_emp</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spec_shape</span><span class="p">,</span> <span class="n">spec_args</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">pdf_params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pdf_range</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">nlcs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  <span class="n">iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">keep_non_converged</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a simulated light curve with a specified PSD and PDF.</span>

<span class="sd">        This method combines the two steps of producting a Gaussian light curve</span>
<span class="sd">        with a given PSD [1] and adjusting its PDF to a specified PDF [2].</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        spec_shape : func</span>
<span class="sd">            Function that takes an array of frequencies and &#39;spec_args&#39; as</span>
<span class="sd">            input and calculates a spectrum for those frequencies.</span>
<span class="sd">        spec_args : list</span>
<span class="sd">            Function arguments to &#39;spec_shape&#39;.</span>
<span class="sd">        pdf : numpy.ndarray or callable</span>
<span class="sd">            When providing flux data in a numpy.array the method will calculate</span>
<span class="sd">            an ECDF of the input data and draw random flux values from that</span>
<span class="sd">            ECDF.</span>
<span class="sd">            When providing a callable function the method will use that</span>
<span class="sd">            function to draw random flux values. Parameters for the function</span>
<span class="sd">            need to be provided in &#39;pdf_params&#39;</span>
<span class="sd">        pdf_params : list, default=None</span>
<span class="sd">            When a callable function is given to &#39;pdf&#39;, corresponding</span>
<span class="sd">            parameters need to be given to &#39;pdf_params&#39;.</span>
<span class="sd">        pdf_range : list</span>
<span class="sd">            List of two elements. Random flux values will be drawn from the</span>
<span class="sd">            given PDF between the two limits provided by &#39;pdf_range&#39;. Required</span>
<span class="sd">            only when a callable function is given to &#39;pdf&#39;. Does not have an</span>
<span class="sd">            effect, when a numpy.ndarray is given to &#39;pdf&#39;.</span>
<span class="sd">        nlcs : int, default=1</span>
<span class="sd">            Set the number of light curves that are produced. See notes below.</span>
<span class="sd">        iterations : int, default=100</span>
<span class="sd">            The algorithm [1] is iterative. This value sets a maximum number of</span>
<span class="sd">            iterations to avoid infinite loops.</span>
<span class="sd">        keep_non_converged : bool or str, default=False</span>
<span class="sd">            If True the result is returned even if the algorithm [1] did not</span>
<span class="sd">            converge.</span>
<span class="sd">            If False and the algorithm [1] did not converge, False is returned.</span>
<span class="sd">            If set to &#39;ask&#39;, a notification is written asking how to proceed.</span>
<span class="sd">        threshold : float, default=0.01</span>
<span class="sd">            Defines when the algorithm [1] is considered as converged.</span>
<span class="sd">            Iterations are stopped when maximum difference between the current</span>
<span class="sd">            and the previous light curve does not exceed this &#39;threshold&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The method will initially produce one long Gaussian light curve with a</span>
<span class="sd">        total time N times longer than the final total time, where N is set by</span>
<span class="sd">        &#39;nlcs&#39;. This long light curve is then split into N individual pieces.</span>
<span class="sd">        Producing one initial long light curves means that power at frequencies</span>
<span class="sd">        N times lower than the final total time is included in the noise</span>
<span class="sd">        process. Setting ncls&gt;1 allows to include low-frequency power.</span>
<span class="sd">        The adjustment of the PDF is then applied to every split light curve</span>
<span class="sd">        individually.</span>

<span class="sd">        References</span>
<span class="sd">        -----</span>
<span class="sd">        [1] Timmer and Koenig, 1995, &#39;On generating power law noise&#39;, A&amp;A, 300,</span>
<span class="sd">            707</span>
<span class="sd">        [2] Emmanoulopoulos et al, 2013, MNRAS, 433, 907</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sim_tk</span><span class="p">(</span><span class="n">spec_shape</span><span class="p">,</span> <span class="n">spec_args</span><span class="p">,</span> <span class="n">nlcs</span><span class="o">=</span><span class="n">nlcs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adjust_pdf</span><span class="p">(</span>
                <span class="n">pdf</span><span class="p">,</span> <span class="n">pdf_params</span><span class="o">=</span><span class="n">pdf_params</span><span class="p">,</span> <span class="n">pdf_range</span><span class="o">=</span><span class="n">pdf_range</span><span class="p">,</span>
                <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span> <span class="n">keep_non_converged</span><span class="o">=</span><span class="n">keep_non_converged</span><span class="p">,</span>
                <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">get_lcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the simulated light curves.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : list</span>
<span class="sd">            List of simulated light curves, each an ArtificialLightCurve</span>
<span class="sd">            instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">ArtificialLightCurve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lc_type</span><span class="p">)</span> \
               <span class="k">for</span> <span class="n">flux</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">lcs</span>


<span class="c1">#==============================================================================</span>
<span class="c1"># FUNCTIONS</span>
<span class="c1">#==============================================================================</span>

<span class="k">def</span> <span class="nf">powerlaw</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns an array of amplitudes following a power-law over the input</span>
<span class="sd">    frequencies.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----</span>
<span class="sd">    frequencies : 1darray</span>
<span class="sd">        Frequencies for which to calculate the power-law in arbitrary units.</span>
<span class="sd">    index : float, default=1.</span>
<span class="sd">        Power-law index.</span>
<span class="sd">    amplitude : float, default=10.</span>
<span class="sd">        Power-law amplitude at &#39;frequency&#39; in arbitrary unit.</span>
<span class="sd">    frequency : float, default=0.1</span>
<span class="sd">        Frequency for the given &#39;amplitude&#39; in same unit as &#39;frequencies&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -----</span>
<span class="sd">    out : 1darray</span>
<span class="sd">        Array of same length as input &#39;frequencies&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">amplitude</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">/</span><span class="n">frequency</span><span class="p">,</span> <span class="o">-</span><span class="n">index</span><span class="p">)</span>

<span class="c1">#==============================================================================</span>

<span class="k">def</span> <span class="nf">kneemodel</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns an array of amplitudes following a constant profile that changes</span>
<span class="sd">    into a power-law around a given frequency.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----</span>
<span class="sd">    frequencies : 1darray</span>
<span class="sd">        Frequencies for which to calculate the power-law in arbitrary units.</span>
<span class="sd">    index : float, default=1.</span>
<span class="sd">        Power-law index.</span>
<span class="sd">    amplitude : float, default=10.</span>
<span class="sd">        Constant amplitude at frequencies below &#39;frequency&#39; in arbitrary unit.</span>
<span class="sd">    frequency : float, default=0.1</span>
<span class="sd">        Frequency  in same unit as &#39;frequencies&#39; at which profile changes</span>
<span class="sd">        into a power-law.</span>

<span class="sd">    Returns</span>
<span class="sd">    -----</span>
<span class="sd">    out : 1darray</span>
<span class="sd">        Array of same length as input &#39;frequencies&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">amplitude</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">/</span><span class="n">frequency</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                               <span class="o">-</span><span class="n">index</span> <span class="o">/</span><span class="mf">2.</span><span class="p">)</span>


<span class="c1">#==============================================================================</span>

<span class="k">def</span> <span class="nf">brokenpowerlaw</span><span class="p">(</span>
        <span class="n">frequencies</span><span class="p">,</span> <span class="n">index_lo</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">index_hi</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns an array of amplitudes following a broken power-law.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----</span>
<span class="sd">    frequencies : array</span>
<span class="sd">        Frequencies for which to calculate the power-law in arbitrary units.</span>
<span class="sd">    index_hi : float, default=2.</span>
<span class="sd">        Power-law index at frequencies lower than &#39;frequency&#39;.</span>
<span class="sd">    index_lo : float, default=1.</span>
<span class="sd">        Power-law index at frequencies higher than &#39;frequency&#39;.</span>
<span class="sd">    frequency : float, default=0.1</span>
<span class="sd">        Frequency of the power-law break in same unit as &#39;frequencies&#39;.</span>
<span class="sd">    amplitude : float, default=10.</span>
<span class="sd">        Amplitude at &#39;frequency&#39; in arbitrary unit.</span>

<span class="sd">    Returns</span>
<span class="sd">    -----</span>
<span class="sd">        Array of same length as input &#39;frequencies&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">frequencies</span><span class="o">&gt;</span><span class="n">frequency</span><span class="p">,</span>
                    <span class="n">amplitude</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">/</span><span class="n">frequency</span><span class="p">,</span> <span class="o">-</span><span class="n">index_hi</span><span class="p">),</span>
                    <span class="n">amplitude</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">/</span><span class="n">frequency</span><span class="p">,</span> <span class="o">-</span><span class="n">index_lo</span><span class="p">))</span>
</pre></div>

  </div>

  </header>

  <section id="section-items">

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="lcsim.brokenpowerlaw">
    <p>def <span class="ident">brokenpowerlaw</span>(</p><p>frequencies, index_lo=1.0, index_hi=2.0, amplitude=10.0, frequency=0.1)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns an array of amplitudes following a broken power-law.</p>
<h2>Parameters</h2>
<p>frequencies : array
    Frequencies for which to calculate the power-law in arbitrary units.
index_hi : float, default=2.
    Power-law index at frequencies lower than 'frequency'.
index_lo : float, default=1.
    Power-law index at frequencies higher than 'frequency'.
frequency : float, default=0.1
    Frequency of the power-law break in same unit as 'frequencies'.
amplitude : float, default=10.
    Amplitude at 'frequency' in arbitrary unit.</p>
<h2>Returns</h2>
<div class="codehilite"><pre><span></span>Array of same length as input &#39;frequencies&#39;.
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-lcsim.brokenpowerlaw', this);">Show source &equiv;</a></p>
  <div id="source-lcsim.brokenpowerlaw" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">brokenpowerlaw</span><span class="p">(</span>
        <span class="n">frequencies</span><span class="p">,</span> <span class="n">index_lo</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">index_hi</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns an array of amplitudes following a broken power-law.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----</span>
<span class="sd">    frequencies : array</span>
<span class="sd">        Frequencies for which to calculate the power-law in arbitrary units.</span>
<span class="sd">    index_hi : float, default=2.</span>
<span class="sd">        Power-law index at frequencies lower than &#39;frequency&#39;.</span>
<span class="sd">    index_lo : float, default=1.</span>
<span class="sd">        Power-law index at frequencies higher than &#39;frequency&#39;.</span>
<span class="sd">    frequency : float, default=0.1</span>
<span class="sd">        Frequency of the power-law break in same unit as &#39;frequencies&#39;.</span>
<span class="sd">    amplitude : float, default=10.</span>
<span class="sd">        Amplitude at &#39;frequency&#39; in arbitrary unit.</span>

<span class="sd">    Returns</span>
<span class="sd">    -----</span>
<span class="sd">        Array of same length as input &#39;frequencies&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">frequencies</span><span class="o">&gt;</span><span class="n">frequency</span><span class="p">,</span>
                    <span class="n">amplitude</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">/</span><span class="n">frequency</span><span class="p">,</span> <span class="o">-</span><span class="n">index_hi</span><span class="p">),</span>
                    <span class="n">amplitude</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">/</span><span class="n">frequency</span><span class="p">,</span> <span class="o">-</span><span class="n">index_lo</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="lcsim.kneemodel">
    <p>def <span class="ident">kneemodel</span>(</p><p>frequencies, index=1.0, amplitude=10.0, frequency=0.1)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns an array of amplitudes following a constant profile that changes
into a power-law around a given frequency.</p>
<h2>Parameters</h2>
<p>frequencies : 1darray
    Frequencies for which to calculate the power-law in arbitrary units.
index : float, default=1.
    Power-law index.
amplitude : float, default=10.
    Constant amplitude at frequencies below 'frequency' in arbitrary unit.
frequency : float, default=0.1
    Frequency  in same unit as 'frequencies' at which profile changes
    into a power-law.</p>
<h2>Returns</h2>
<p>out : 1darray
    Array of same length as input 'frequencies'.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-lcsim.kneemodel', this);">Show source &equiv;</a></p>
  <div id="source-lcsim.kneemodel" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">kneemodel</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns an array of amplitudes following a constant profile that changes</span>
<span class="sd">    into a power-law around a given frequency.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----</span>
<span class="sd">    frequencies : 1darray</span>
<span class="sd">        Frequencies for which to calculate the power-law in arbitrary units.</span>
<span class="sd">    index : float, default=1.</span>
<span class="sd">        Power-law index.</span>
<span class="sd">    amplitude : float, default=10.</span>
<span class="sd">        Constant amplitude at frequencies below &#39;frequency&#39; in arbitrary unit.</span>
<span class="sd">    frequency : float, default=0.1</span>
<span class="sd">        Frequency  in same unit as &#39;frequencies&#39; at which profile changes</span>
<span class="sd">        into a power-law.</span>

<span class="sd">    Returns</span>
<span class="sd">    -----</span>
<span class="sd">    out : 1darray</span>
<span class="sd">        Array of same length as input &#39;frequencies&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">amplitude</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">/</span><span class="n">frequency</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                               <span class="o">-</span><span class="n">index</span> <span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="lcsim.powerlaw">
    <p>def <span class="ident">powerlaw</span>(</p><p>frequencies, index=1.0, amplitude=10.0, frequency=0.1)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns an array of amplitudes following a power-law over the input
frequencies.</p>
<h2>Parameters</h2>
<p>frequencies : 1darray
    Frequencies for which to calculate the power-law in arbitrary units.
index : float, default=1.
    Power-law index.
amplitude : float, default=10.
    Power-law amplitude at 'frequency' in arbitrary unit.
frequency : float, default=0.1
    Frequency for the given 'amplitude' in same unit as 'frequencies'.</p>
<h2>Returns</h2>
<p>out : 1darray
    Array of same length as input 'frequencies'.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-lcsim.powerlaw', this);">Show source &equiv;</a></p>
  <div id="source-lcsim.powerlaw" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">powerlaw</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns an array of amplitudes following a power-law over the input</span>
<span class="sd">    frequencies.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----</span>
<span class="sd">    frequencies : 1darray</span>
<span class="sd">        Frequencies for which to calculate the power-law in arbitrary units.</span>
<span class="sd">    index : float, default=1.</span>
<span class="sd">        Power-law index.</span>
<span class="sd">    amplitude : float, default=10.</span>
<span class="sd">        Power-law amplitude at &#39;frequency&#39; in arbitrary unit.</span>
<span class="sd">    frequency : float, default=0.1</span>
<span class="sd">        Frequency for the given &#39;amplitude&#39; in same unit as &#39;frequencies&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -----</span>
<span class="sd">    out : 1darray</span>
<span class="sd">        Array of same length as input &#39;frequencies&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">amplitude</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">/</span><span class="n">frequency</span><span class="p">,</span> <span class="o">-</span><span class="n">index</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="lcsim.ArtificialLightCurve" class="name">class <span class="ident">ArtificialLightCurve</span></p>
      
  
    <div class="desc"><p>Process an artificial light curve.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-lcsim.ArtificialLightCurve', this);">Show source &equiv;</a></p>
  <div id="source-lcsim.ArtificialLightCurve" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">ArtificialLightCurve</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Process an artificial light curve.&quot;&quot;&quot;</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">lc_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an instance of ArtificialLightCurve.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        time : np.ndarray</span>
<span class="sd">            Time steps.</span>
<span class="sd">        flux : np.ndarray</span>
<span class="sd">            Flux values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : ArtificialLightCurve-instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span> <span class="o">=</span> <span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_orig</span> <span class="o">=</span> <span class="n">flux</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lc_type</span> <span class="o">=</span> <span class="n">lc_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_total</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_sampling</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span><span class="o">.</span><span class="n">size</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_res</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_res_total</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_res_sampling</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns gereneral information about the simulated data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;Artificial light curve</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Simulation type:        {0:&gt;10s}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lc_type</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Original time sampling: {0:10.3f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_sampling</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Original total time:    {0:10.3f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_total</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span> <span class="o">==</span> <span class="s1">&#39;const&#39;</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Resampled-------------------------</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Time steps:             {0:&gt;10s}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;even&#39;</span><span class="p">)</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Time sampling:          {0:10.3f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">time_res_sampling</span><span class="p">)</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Total time:             {0:10.3f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">time_res_total</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;powerlaw&#39;</span><span class="p">,</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">,</span> <span class="s1">&#39;ecdf&#39;</span><span class="p">,</span> <span class="s1">&#39;specific&#39;</span><span class="p">]:</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Resampled-------------------------</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Time steps:             {0:&gt;10s}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;uneven&#39;</span><span class="p">)</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Distribution:           {0:&gt;10s}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resampled</span><span class="p">)</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Median time sampling:   {0:10.3f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">time_res_sampling</span><span class="p">)</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Total time:             {0:10.3f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">time_res_total</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="o">==</span> <span class="s1">&#39;const&#39;</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Gaussian noise added--------------</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Uncertainties:  {0:&gt;18s}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;homoscedastic&#39;</span><span class="p">)</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Median uncertainty:     {0:10.3f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;specific&#39;</span><span class="p">,</span> <span class="s1">&#39;ecdf&#39;</span><span class="p">,</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">]:</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Gaussian noise added--------------</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Uncertainties:  {0:&gt;18s}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;heteroscedastic&#39;</span><span class="p">)</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Distribution:   {0:&gt;18s}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span><span class="p">)</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;Median uncertainty:     {0:10.3f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">text</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_draw_from_powerlaw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">minval</span><span class="p">,</span> <span class="n">maxval</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draws random numbers from a truncated power-law distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        index : float</span>
<span class="sd">            Power-law index.</span>
<span class="sd">        minval : float</span>
<span class="sd">            Lower limit of the distribution.</span>
<span class="sd">        maxval : float</span>
<span class="sd">            Upper limit of the distribution.</span>
<span class="sd">        size : int, default=1</span>
<span class="sd">            Number of random data points to return.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : np.1darray</span>
<span class="sd">            Random numbers.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mf">1.</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">((</span><span class="n">maxval</span><span class="o">**</span><span class="n">index</span> <span class="o">-</span> <span class="n">minval</span><span class="o">**</span><span class="n">index</span><span class="p">)</span> \
                        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="n">minval</span><span class="o">**</span><span class="n">index</span><span class="p">,</span>
                        <span class="mf">1.</span> <span class="o">/</span> <span class="n">index</span><span class="p">)</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_draw_from_ecdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draws random number from an empirical cumulative distribution</span>
<span class="sd">        function (ECDF) defined by given data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        data : np.1darray</span>
<span class="sd">            The data which defines the ECDF.</span>
<span class="sd">        size : int, default=1</span>
<span class="sd">            Number of random data points to return.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : np.1darray</span>
<span class="sd">            Random numbers.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ecdf</span> <span class="o">=</span> <span class="n">ECDF</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">draw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">ecdf</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">draw</span><span class="p">,</span> <span class="n">ecdf</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">ecdf</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_random_timesteps</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">total_time</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="s1">&#39;powerlaw&#39;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">recursion</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates random time data points with time steps following a given</span>
<span class="sd">        distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        total_time : float</span>
<span class="sd">            The total time to cover by the time data points</span>
<span class="sd">        dist : str, default=&#39;powerlaw&#39;</span>
<span class="sd">            Defines the distribution the time steps are drawn from. Choose from</span>
<span class="sd">            truncated &#39;powerlaw&#39;, &#39;lognormal&#39; and &#39;ecdf&#39;. The distribution</span>
<span class="sd">            parameters need to be set accordingly in the &#39;params&#39;.</span>
<span class="sd">        params : list</span>
<span class="sd">            A list of distribution parameters.</span>
<span class="sd">            For &#39;powerlaw&#39; give (1) the power-law index, (2) the lower, and (3)</span>
<span class="sd">            the upper limit of the truncated distribution.</span>
<span class="sd">            For &#39;lognormal&#39; give the distribution (1) mu and (2) sigma.</span>
<span class="sd">            For &#39;ecdf&#39; give an array of time steps (differences between time</span>
<span class="sd">            data points not the time data points!).</span>
<span class="sd">        recursion : int, default=0</span>
<span class="sd">            Do not manually set a value. This parameter is needed internally</span>
<span class="sd">            when the drawn time steps are not enough to cover the targeted</span>
<span class="sd">            total time and a recursion call of the function is necessery.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : np.1darray</span>
<span class="sd">            Random time data points.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># determine number of time steps to create:</span>
        <span class="k">if</span> <span class="n">recursion</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">recursion</span>

        <span class="k">elif</span> <span class="n">dist</span> <span class="o">==</span> <span class="s1">&#39;powerlaw&#39;</span> <span class="ow">and</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">2.</span><span class="p">:</span>
            <span class="n">mean_sampling</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> \
                             <span class="o">-</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> \
                             <span class="o">/</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> \
                                <span class="o">-</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> \
                             <span class="o">*</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">total_time</span> <span class="o">/</span> <span class="n">mean_sampling</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">mean_sampling</span>

        <span class="k">elif</span> <span class="n">dist</span><span class="o">==</span><span class="s1">&#39;lognormal&#39;</span><span class="p">:</span>
            <span class="n">mean_sampling</span> <span class="o">=</span> <span class="n">exp</span><span class="p">((</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">total_time</span> <span class="o">/</span> <span class="n">mean_sampling</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">mean_sampling</span>

        <span class="k">elif</span> <span class="n">dist</span><span class="o">==</span><span class="s1">&#39;ecdf&#39;</span><span class="p">:</span>
            <span class="n">mean_sampling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">total_time</span> <span class="o">/</span> <span class="n">mean_sampling</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">mean_sampling</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">100</span>

        <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">10</span>

        <span class="c1"># create random time steps:</span>
        <span class="k">if</span> <span class="n">dist</span><span class="o">==</span><span class="s1">&#39;powerlaw&#39;</span><span class="p">:</span>
            <span class="n">steps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_draw_from_powerlaw</span><span class="p">(</span>
                    <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">dist</span><span class="o">==</span><span class="s1">&#39;lognormal&#39;</span><span class="p">:</span>
            <span class="n">steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">lognormal</span><span class="p">(</span>
                    <span class="n">mean</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigma</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">dist</span><span class="o">==</span><span class="s1">&#39;ecdf&#39;</span><span class="p">:</span>
            <span class="n">steps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_draw_from_ecdf</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Distribution type &#39;{0:s}&#39; is not supported. Either set &quot;</span> \
                    <span class="s2">&quot;to &#39;powerlaw&#39;, &#39;lognormal&#39;, or &#39;ecdf&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dist</span><span class="p">))</span>

        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

        <span class="c1"># recursion, if time steps do not cover total time:</span>
        <span class="k">if</span> <span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">total_time</span><span class="p">:</span>
           <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">total_time</span><span class="p">)</span> <span class="o">*</span> <span class="n">size</span><span class="p">))</span>
           <span class="n">more</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_timesteps</span><span class="p">(</span>
                   <span class="n">total_time</span><span class="o">-</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dist</span><span class="o">=</span><span class="n">dist</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
                   <span class="n">recursion</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
           <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">time</span><span class="p">,</span> <span class="n">more</span><span class="o">+</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">recursion</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">time</span>

        <span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="n">time</span><span class="o">&lt;=</span><span class="n">total_time</span><span class="p">]</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">time</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">time</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_steps</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resample the artificial light curve.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        time_steps : float, numpy.ndarray, or str</span>
<span class="sd">            See notes for details.</span>
<span class="sd">        params : list or numpy.ndarray, default=None</span>
<span class="sd">            See notes for details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method provides several options to resample the artificial data to</span>
<span class="sd">        an even or uneven time grid:</span>
<span class="sd">        1. Provide a float for &#39;time_steps&#39; to resample to an even time grid.</span>
<span class="sd">        2. Provide a numpy.ndarray for &#39;time steps&#39;. The light curve will be</span>
<span class="sd">           resampled to these time stamps. The light curve will be cut off,</span>
<span class="sd">           when the provided array exceeds the total time of the simulated</span>
<span class="sd">           data. Note that the simulated data starts at time 0.</span>
<span class="sd">        3. Set &#39;time_steps&#39; to &#39;ecdf&#39; and provide a numpy.ndarray of time</span>
<span class="sd">           stamps to &#39;params&#39;. The method will calculate the ECDF of time steps</span>
<span class="sd">           (i.e. time differences) between the provided time data and then</span>
<span class="sd">           randomly draw time steps from the ECDF to construct a new series of</span>
<span class="sd">           time stamps.</span>
<span class="sd">        4. Set &#39;time_steps&#39; to &#39;powerlaw&#39; and provide a list of three</span>
<span class="sd">           parameters to &#39;param&#39;: (1) the power-law index, (2) the lower, and</span>
<span class="sd">           (3) the upper limit of the truncated distribution.</span>
<span class="sd">           Time steps will be randomly drawn from this distribution to</span>
<span class="sd">           construct a new series of time stamps.</span>
<span class="sd">        5. Set &#39;time_steps&#39; to &#39;lognormal&#39; and provide a list of two parameters</span>
<span class="sd">           to &#39;param&#39;: (1) mu and (2) sigma.</span>
<span class="sd">           Time steps will be randomly drawn from this distribution to</span>
<span class="sd">           construct a new series of time stamps.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># even time sampling:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_steps</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="c1"># time step is shorter than original time sampling:</span>
            <span class="k">if</span> <span class="n">time_steps</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_sampling</span><span class="p">:</span>
                <span class="k">print</span> <span class="s1">&#39;Requested time step is shorter or equal to original &#39;</span> \
                      <span class="s1">&#39;sampling. resample() aborted.&#39;</span>
                <span class="k">return</span> <span class="bp">False</span>

            <span class="c1"># time step is a multiple of the original sampling:</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">time_steps</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_sampling</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ratio</span><span class="p">)</span> <span class="o">%</span> <span class="mf">1.</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span><span class="p">[::</span><span class="n">n</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flux_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_orig</span><span class="p">[::</span><span class="n">n</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span> <span class="o">=</span> <span class="s1">&#39;const&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_res_total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_res_sampling</span> <span class="o">=</span> <span class="n">time_steps</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="o">.</span><span class="n">size</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="k">print</span> <span class="s1">&#39;Note: resampling removed the error simulation.&#39;</span>

                <span class="k">return</span> <span class="bp">True</span>

            <span class="c1"># time step requires interpolation:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_total</span><span class="p">,</span> <span class="n">time_steps</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span> <span class="o">=</span> <span class="s1">&#39;const&#39;</span>

        <span class="c1"># resample to specified time steps:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_steps</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># check that time steps are within total time:</span>
            <span class="n">time_steps</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">time_steps</span><span class="p">)</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="n">time_steps</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_total</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span> <span class="o">=</span> <span class="n">time_steps</span><span class="p">[</span><span class="n">sel</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span> <span class="o">=</span> <span class="s1">&#39;specific&#39;</span>

        <span class="c1"># draw time steps from ECDF of time steps:</span>
        <span class="k">elif</span> <span class="n">time_steps</span> <span class="o">==</span> <span class="s1">&#39;ecdf&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_timesteps</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_total</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="s1">&#39;ecdf&#39;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span> <span class="o">=</span> <span class="s1">&#39;ecdf&#39;</span>

        <span class="c1"># draw time steps from powerlaw or log-normal distribution:</span>
        <span class="k">elif</span> <span class="n">time_steps</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;powerlaw&#39;</span><span class="p">,</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_timesteps</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_total</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="n">time_steps</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span> <span class="o">=</span> <span class="n">time_steps</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported input for &#39;time_steps&#39;.&quot;</span><span class="p">)</span>

        <span class="c1"># interpolate data:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_orig</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_res_total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">time_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_res_sampling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">time_diff</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="o">.</span><span class="n">size</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">add_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uncertainties</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add Gaussian noise to the artificial light curve.</span>

<span class="sd">        An error term is drawn randomly for each data point from a Gaussian</span>
<span class="sd">        distribution and added to the simulated data:</span>

<span class="sd">        .. math::</span>
<span class="sd">            f_{\mathrm{sim},i} \\rightarrow f_{\mathrm{sim},i} + f_{\mathrm{err},i}</span>

<span class="sd">        with</span>


<span class="sd">        .. math::</span>
<span class="sd">            f_{\mathrm{err},i} \sim \\mathcal{N}(0, \sigma_i)</span>

<span class="sd">        The noise scale sigma_i can be be the same for all data points or vary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        uncertainties : float, numpy.ndarray, or str</span>
<span class="sd">            See notes for details.</span>
<span class="sd">        params : list or numpy.ndarray, default=None</span>
<span class="sd">            See notes for details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method provides several options to add homoscedastic and</span>
<span class="sd">        heteroscedastic error to the artificial data:</span>
<span class="sd">        1. Provide a float for &#39;uncertainties&#39; to use the same uncertainty</span>
<span class="sd">           scale for each data point (homoscedasticity).</span>
<span class="sd">        2. Provide a numpy.ndarray for &#39;uncertainties&#39;. The values in the array</span>
<span class="sd">           are used as the uncertainty scales for each corresponding data</span>
<span class="sd">           point. Note that the length of &#39;uncertainties&#39; needs to match the</span>
<span class="sd">           length of the simulated light curve.</span>
<span class="sd">        3. Set &#39;uncertainties&#39; to &#39;ecdf&#39; and provide a numpy.ndarray of</span>
<span class="sd">           uncertainties to &#39;params&#39;. The method will calculate the ECDF of the</span>
<span class="sd">           uncertainties and then randomly draw uncertainties from the ECDF.</span>
<span class="sd">        4. Set &#39;uncertainties&#39; to &#39;lognormal&#39; and provide a list of two</span>
<span class="sd">           parameters to &#39;param&#39;: (1) mu and (2) sigma.</span>
<span class="sd">           Uncertainties are randomly drawn from this distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># homoscedastic uncertainties:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uncertainties</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="n">uncertainties</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="o">=</span> <span class="s1">&#39;const&#39;</span>

        <span class="c1"># specific uncertainties:</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uncertainties</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="n">uncertainties</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span> <span class="o">=</span> <span class="n">uncertainties</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="o">=</span> <span class="s1">&#39;specific&#39;</span>

        <span class="c1"># draw uncertainties from ECDF of uncertainties:</span>
        <span class="k">elif</span> <span class="n">uncertainties</span> <span class="o">==</span> <span class="s1">&#39;ecdf&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_draw_from_ecdf</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="o">=</span> <span class="s1">&#39;ecdf&#39;</span>

        <span class="c1"># draw uncertainties from log-normal distribution:</span>
        <span class="k">elif</span> <span class="n">uncertainties</span> <span class="o">==</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">lognormal</span><span class="p">(</span>
                    <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="o">=</span> <span class="s1">&#39;lognormal&#39;</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported input for &#39;uncertainties&#39;.&quot;</span><span class="p">)</span>

        <span class="c1"># apply errors:</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_res</span> <span class="o">+</span> <span class="n">err</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_orig</span> <span class="o">+</span> <span class="n">err</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">get_all</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the simulated light curve data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        get_all : bool, default=False</span>
<span class="sd">            As default returns only the final light curve data, i.e. the</span>
<span class="sd">            resampled and/or noise-added light curve.</span>
<span class="sd">            If True, returns all data including the original sampling.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : dict</span>
<span class="sd">            Simulated light curve data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># return all light curves (original, resampled, errors added):</span>
        <span class="k">if</span> <span class="n">get_all</span><span class="p">:</span>
            <span class="c1"># add original light curve:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;time_orig&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span><span class="p">,</span>
                    <span class="s1">&#39;flux_orig&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_orig</span><span class="p">}</span>

            <span class="c1"># add resampled light curve (if available):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="s1">&#39;time_res&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span>
                <span class="n">results</span><span class="p">[</span><span class="s1">&#39;flux_res&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_res</span>

            <span class="c1"># add error-added light curve (if available):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="s1">&#39;flux_err&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span>
                <span class="n">results</span><span class="p">[</span><span class="s1">&#39;flux_unc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span>

        <span class="c1"># return final light curve (resampled and error-added):</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">,</span>
                    <span class="s1">&#39;flux&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span><span class="p">,</span>
                    <span class="s1">&#39;flux_unc&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span><span class="p">}</span>

        <span class="c1"># return final light curve (error-added):</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span><span class="p">,</span>
                    <span class="s1">&#39;flux&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span><span class="p">,</span>
                    <span class="s1">&#39;flux_unc&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span><span class="p">}</span>

        <span class="c1"># return final light curve (resampled):</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">,</span>
                    <span class="s1">&#39;flux&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_res</span><span class="p">}</span>

        <span class="c1"># return final light curve (original):</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span><span class="p">,</span>
                    <span class="s1">&#39;flux&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_orig</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">results</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#lcsim.ArtificialLightCurve">ArtificialLightCurve</a></li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="lcsim.ArtificialLightCurve.error_sim" class="name">var <span class="ident">error_sim</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="lcsim.ArtificialLightCurve.flux_err" class="name">var <span class="ident">flux_err</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="lcsim.ArtificialLightCurve.flux_orig" class="name">var <span class="ident">flux_orig</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="lcsim.ArtificialLightCurve.flux_res" class="name">var <span class="ident">flux_res</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="lcsim.ArtificialLightCurve.flux_unc" class="name">var <span class="ident">flux_unc</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="lcsim.ArtificialLightCurve.lc_type" class="name">var <span class="ident">lc_type</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="lcsim.ArtificialLightCurve.resampled" class="name">var <span class="ident">resampled</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="lcsim.ArtificialLightCurve.size" class="name">var <span class="ident">size</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="lcsim.ArtificialLightCurve.time_orig" class="name">var <span class="ident">time_orig</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="lcsim.ArtificialLightCurve.time_orig_sampling" class="name">var <span class="ident">time_orig_sampling</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="lcsim.ArtificialLightCurve.time_orig_total" class="name">var <span class="ident">time_orig_total</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="lcsim.ArtificialLightCurve.time_res" class="name">var <span class="ident">time_res</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="lcsim.ArtificialLightCurve.time_res_sampling" class="name">var <span class="ident">time_res_sampling</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="lcsim.ArtificialLightCurve.time_res_total" class="name">var <span class="ident">time_res_total</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="lcsim.ArtificialLightCurve.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, time, flux, lc_type)</p>
    </div>
    

    
  
    <div class="desc"><p>Create an instance of ArtificialLightCurve.</p>
<h2>Parameters</h2>
<p>time : np.ndarray
    Time steps.
flux : np.ndarray
    Flux values.</p>
<h2>Returns</h2>
<p>out : ArtificialLightCurve-instance</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-lcsim.ArtificialLightCurve.__init__', this);">Show source &equiv;</a></p>
  <div id="source-lcsim.ArtificialLightCurve.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">lc_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create an instance of ArtificialLightCurve.</span>
<span class="sd">    Parameters</span>
<span class="sd">    -----</span>
<span class="sd">    time : np.ndarray</span>
<span class="sd">        Time steps.</span>
<span class="sd">    flux : np.ndarray</span>
<span class="sd">        Flux values.</span>
<span class="sd">    Returns</span>
<span class="sd">    -----</span>
<span class="sd">    out : ArtificialLightCurve-instance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span> <span class="o">=</span> <span class="n">time</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">flux_orig</span> <span class="o">=</span> <span class="n">flux</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lc_type</span> <span class="o">=</span> <span class="n">lc_type</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_total</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_sampling</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span><span class="o">.</span><span class="n">size</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">flux_res</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">time_res_total</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">time_res_sampling</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span> <span class="o">=</span> <span class="bp">None</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="lcsim.ArtificialLightCurve.add_errors">
    <p>def <span class="ident">add_errors</span>(</p><p>self, uncertainties, params=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Add Gaussian noise to the artificial light curve.</p>
<p>An error term is drawn randomly for each data point from a Gaussian
distribution and added to the simulated data:</p>
<p>.. math::
    f_{\mathrm{sim},i} \rightarrow f_{\mathrm{sim},i} + f_{\mathrm{err},i}</p>
<p>with</p>
<p>.. math::
    f_{\mathrm{err},i} \sim \mathcal{N}(0, \sigma_i)</p>
<p>The noise scale sigma_i can be be the same for all data points or vary.</p>
<h2>Parameters</h2>
<p>uncertainties : float, numpy.ndarray, or str
    See notes for details.
params : list or numpy.ndarray, default=None
    See notes for details.</p>
<h2>Returns</h2>
<p>None</p>
<h2>Notes</h2>
<p>This method provides several options to add homoscedastic and
heteroscedastic error to the artificial data:
1. Provide a float for 'uncertainties' to use the same uncertainty
   scale for each data point (homoscedasticity).
2. Provide a numpy.ndarray for 'uncertainties'. The values in the array
   are used as the uncertainty scales for each corresponding data
   point. Note that the length of 'uncertainties' needs to match the
   length of the simulated light curve.
3. Set 'uncertainties' to 'ecdf' and provide a numpy.ndarray of
   uncertainties to 'params'. The method will calculate the ECDF of the
   uncertainties and then randomly draw uncertainties from the ECDF.
4. Set 'uncertainties' to 'lognormal' and provide a list of two
   parameters to 'param': (1) mu and (2) sigma.
   Uncertainties are randomly drawn from this distribution.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-lcsim.ArtificialLightCurve.add_errors', this);">Show source &equiv;</a></p>
  <div id="source-lcsim.ArtificialLightCurve.add_errors" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">add_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uncertainties</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add Gaussian noise to the artificial light curve.</span>
<span class="sd">    An error term is drawn randomly for each data point from a Gaussian</span>
<span class="sd">    distribution and added to the simulated data:</span>
<span class="sd">    .. math::</span>
<span class="sd">        f_{\mathrm{sim},i} \\rightarrow f_{\mathrm{sim},i} + f_{\mathrm{err},i}</span>
<span class="sd">    with</span>
<span class="sd">    .. math::</span>
<span class="sd">        f_{\mathrm{err},i} \sim \\mathcal{N}(0, \sigma_i)</span>
<span class="sd">    The noise scale sigma_i can be be the same for all data points or vary.</span>
<span class="sd">    Parameters</span>
<span class="sd">    -----</span>
<span class="sd">    uncertainties : float, numpy.ndarray, or str</span>
<span class="sd">        See notes for details.</span>
<span class="sd">    params : list or numpy.ndarray, default=None</span>
<span class="sd">        See notes for details.</span>
<span class="sd">    Returns</span>
<span class="sd">    -----</span>
<span class="sd">    None</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This method provides several options to add homoscedastic and</span>
<span class="sd">    heteroscedastic error to the artificial data:</span>
<span class="sd">    1. Provide a float for &#39;uncertainties&#39; to use the same uncertainty</span>
<span class="sd">       scale for each data point (homoscedasticity).</span>
<span class="sd">    2. Provide a numpy.ndarray for &#39;uncertainties&#39;. The values in the array</span>
<span class="sd">       are used as the uncertainty scales for each corresponding data</span>
<span class="sd">       point. Note that the length of &#39;uncertainties&#39; needs to match the</span>
<span class="sd">       length of the simulated light curve.</span>
<span class="sd">    3. Set &#39;uncertainties&#39; to &#39;ecdf&#39; and provide a numpy.ndarray of</span>
<span class="sd">       uncertainties to &#39;params&#39;. The method will calculate the ECDF of the</span>
<span class="sd">       uncertainties and then randomly draw uncertainties from the ECDF.</span>
<span class="sd">    4. Set &#39;uncertainties&#39; to &#39;lognormal&#39; and provide a list of two</span>
<span class="sd">       parameters to &#39;param&#39;: (1) mu and (2) sigma.</span>
<span class="sd">       Uncertainties are randomly drawn from this distribution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># homoscedastic uncertainties:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uncertainties</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="n">uncertainties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="o">=</span> <span class="s1">&#39;const&#39;</span>
    <span class="c1"># specific uncertainties:</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uncertainties</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> \
            <span class="ow">and</span> <span class="n">uncertainties</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span> <span class="o">=</span> <span class="n">uncertainties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="o">=</span> <span class="s1">&#39;specific&#39;</span>
    <span class="c1"># draw uncertainties from ECDF of uncertainties:</span>
    <span class="k">elif</span> <span class="n">uncertainties</span> <span class="o">==</span> <span class="s1">&#39;ecdf&#39;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_draw_from_ecdf</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="o">=</span> <span class="s1">&#39;ecdf&#39;</span>
    <span class="c1"># draw uncertainties from log-normal distribution:</span>
    <span class="k">elif</span> <span class="n">uncertainties</span> <span class="o">==</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">lognormal</span><span class="p">(</span>
                <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="o">=</span> <span class="s1">&#39;lognormal&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported input for &#39;uncertainties&#39;.&quot;</span><span class="p">)</span>
    <span class="c1"># apply errors:</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_res</span> <span class="o">+</span> <span class="n">err</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_orig</span> <span class="o">+</span> <span class="n">err</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="lcsim.ArtificialLightCurve.data">
    <p>def <span class="ident">data</span>(</p><p>self, get_all=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the simulated light curve data.</p>
<h2>Parameters</h2>
<p>get_all : bool, default=False
    As default returns only the final light curve data, i.e. the
    resampled and/or noise-added light curve.
    If True, returns all data including the original sampling.</p>
<h2>Returns</h2>
<p>out : dict
    Simulated light curve data.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-lcsim.ArtificialLightCurve.data', this);">Show source &equiv;</a></p>
  <div id="source-lcsim.ArtificialLightCurve.data" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">get_all</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the simulated light curve data.</span>
<span class="sd">    Parameters</span>
<span class="sd">    -----</span>
<span class="sd">    get_all : bool, default=False</span>
<span class="sd">        As default returns only the final light curve data, i.e. the</span>
<span class="sd">        resampled and/or noise-added light curve.</span>
<span class="sd">        If True, returns all data including the original sampling.</span>
<span class="sd">    Returns</span>
<span class="sd">    -----</span>
<span class="sd">    out : dict</span>
<span class="sd">        Simulated light curve data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># return all light curves (original, resampled, errors added):</span>
    <span class="k">if</span> <span class="n">get_all</span><span class="p">:</span>
        <span class="c1"># add original light curve:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;time_orig&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span><span class="p">,</span>
                <span class="s1">&#39;flux_orig&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_orig</span><span class="p">}</span>
        <span class="c1"># add resampled light curve (if available):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;time_res&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;flux_res&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_res</span>
        <span class="c1"># add error-added light curve (if available):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;flux_err&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;flux_unc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span>
    <span class="c1"># return final light curve (resampled and error-added):</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">,</span>
                <span class="s1">&#39;flux&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span><span class="p">,</span>
                <span class="s1">&#39;flux_unc&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span><span class="p">}</span>
    <span class="c1"># return final light curve (error-added):</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span><span class="p">,</span>
                <span class="s1">&#39;flux&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span><span class="p">,</span>
                <span class="s1">&#39;flux_unc&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span><span class="p">}</span>
    <span class="c1"># return final light curve (resampled):</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">,</span>
                <span class="s1">&#39;flux&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_res</span><span class="p">}</span>
    <span class="c1"># return final light curve (original):</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span><span class="p">,</span>
                <span class="s1">&#39;flux&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_orig</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">results</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="lcsim.ArtificialLightCurve.resample">
    <p>def <span class="ident">resample</span>(</p><p>self, time_steps, params=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Resample the artificial light curve.</p>
<h2>Parameters</h2>
<p>time_steps : float, numpy.ndarray, or str
    See notes for details.
params : list or numpy.ndarray, default=None
    See notes for details.</p>
<h2>Returns</h2>
<p>None</p>
<h2>Notes</h2>
<p>This method provides several options to resample the artificial data to
an even or uneven time grid:
1. Provide a float for 'time_steps' to resample to an even time grid.
2. Provide a numpy.ndarray for 'time steps'. The light curve will be
   resampled to these time stamps. The light curve will be cut off,
   when the provided array exceeds the total time of the simulated
   data. Note that the simulated data starts at time 0.
3. Set 'time_steps' to 'ecdf' and provide a numpy.ndarray of time
   stamps to 'params'. The method will calculate the ECDF of time steps
   (i.e. time differences) between the provided time data and then
   randomly draw time steps from the ECDF to construct a new series of
   time stamps.
4. Set 'time_steps' to 'powerlaw' and provide a list of three
   parameters to 'param': (1) the power-law index, (2) the lower, and
   (3) the upper limit of the truncated distribution.
   Time steps will be randomly drawn from this distribution to
   construct a new series of time stamps.
5. Set 'time_steps' to 'lognormal' and provide a list of two parameters
   to 'param': (1) mu and (2) sigma.
   Time steps will be randomly drawn from this distribution to
   construct a new series of time stamps.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-lcsim.ArtificialLightCurve.resample', this);">Show source &equiv;</a></p>
  <div id="source-lcsim.ArtificialLightCurve.resample" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_steps</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Resample the artificial light curve.</span>
<span class="sd">    Parameters</span>
<span class="sd">    -----</span>
<span class="sd">    time_steps : float, numpy.ndarray, or str</span>
<span class="sd">        See notes for details.</span>
<span class="sd">    params : list or numpy.ndarray, default=None</span>
<span class="sd">        See notes for details.</span>
<span class="sd">    Returns</span>
<span class="sd">    -----</span>
<span class="sd">    None</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This method provides several options to resample the artificial data to</span>
<span class="sd">    an even or uneven time grid:</span>
<span class="sd">    1. Provide a float for &#39;time_steps&#39; to resample to an even time grid.</span>
<span class="sd">    2. Provide a numpy.ndarray for &#39;time steps&#39;. The light curve will be</span>
<span class="sd">       resampled to these time stamps. The light curve will be cut off,</span>
<span class="sd">       when the provided array exceeds the total time of the simulated</span>
<span class="sd">       data. Note that the simulated data starts at time 0.</span>
<span class="sd">    3. Set &#39;time_steps&#39; to &#39;ecdf&#39; and provide a numpy.ndarray of time</span>
<span class="sd">       stamps to &#39;params&#39;. The method will calculate the ECDF of time steps</span>
<span class="sd">       (i.e. time differences) between the provided time data and then</span>
<span class="sd">       randomly draw time steps from the ECDF to construct a new series of</span>
<span class="sd">       time stamps.</span>
<span class="sd">    4. Set &#39;time_steps&#39; to &#39;powerlaw&#39; and provide a list of three</span>
<span class="sd">       parameters to &#39;param&#39;: (1) the power-law index, (2) the lower, and</span>
<span class="sd">       (3) the upper limit of the truncated distribution.</span>
<span class="sd">       Time steps will be randomly drawn from this distribution to</span>
<span class="sd">       construct a new series of time stamps.</span>
<span class="sd">    5. Set &#39;time_steps&#39; to &#39;lognormal&#39; and provide a list of two parameters</span>
<span class="sd">       to &#39;param&#39;: (1) mu and (2) sigma.</span>
<span class="sd">       Time steps will be randomly drawn from this distribution to</span>
<span class="sd">       construct a new series of time stamps.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># even time sampling:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_steps</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="c1"># time step is shorter than original time sampling:</span>
        <span class="k">if</span> <span class="n">time_steps</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_sampling</span><span class="p">:</span>
            <span class="k">print</span> <span class="s1">&#39;Requested time step is shorter or equal to original &#39;</span> \
                  <span class="s1">&#39;sampling. resample() aborted.&#39;</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="c1"># time step is a multiple of the original sampling:</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="n">time_steps</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_sampling</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ratio</span><span class="p">)</span> <span class="o">%</span> <span class="mf">1.</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span><span class="p">[::</span><span class="n">n</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flux_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_orig</span><span class="p">[::</span><span class="n">n</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span> <span class="o">=</span> <span class="s1">&#39;const&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_res_total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_res_sampling</span> <span class="o">=</span> <span class="n">time_steps</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="o">.</span><span class="n">size</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error_sim</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flux_unc</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">print</span> <span class="s1">&#39;Note: resampling removed the error simulation.&#39;</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="c1"># time step requires interpolation:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_total</span><span class="p">,</span> <span class="n">time_steps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span> <span class="o">=</span> <span class="s1">&#39;const&#39;</span>
    <span class="c1"># resample to specified time steps:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_steps</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># check that time steps are within total time:</span>
        <span class="n">time_steps</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">time_steps</span><span class="p">)</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="n">time_steps</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_total</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span> <span class="o">=</span> <span class="n">time_steps</span><span class="p">[</span><span class="n">sel</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span> <span class="o">=</span> <span class="s1">&#39;specific&#39;</span>
    <span class="c1"># draw time steps from ECDF of time steps:</span>
    <span class="k">elif</span> <span class="n">time_steps</span> <span class="o">==</span> <span class="s1">&#39;ecdf&#39;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_timesteps</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_total</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="s1">&#39;ecdf&#39;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span> <span class="o">=</span> <span class="s1">&#39;ecdf&#39;</span>
    <span class="c1"># draw time steps from powerlaw or log-normal distribution:</span>
    <span class="k">elif</span> <span class="n">time_steps</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;powerlaw&#39;</span><span class="p">,</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">]:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_timesteps</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_orig_total</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="n">time_steps</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span> <span class="o">=</span> <span class="n">time_steps</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported input for &#39;time_steps&#39;.&quot;</span><span class="p">)</span>
    <span class="c1"># interpolate data:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">flux_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_orig</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">time_res_total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">time_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">time_res_sampling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">time_diff</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_res</span><span class="o">.</span><span class="n">size</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="lcsim.LightCurveSimulator" class="name">class <span class="ident">LightCurveSimulator</span></p>
      
  
    <div class="desc"><p>Simulate blazar light curves as a random noise process.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-lcsim.LightCurveSimulator', this);">Show source &equiv;</a></p>
  <div id="source-lcsim.LightCurveSimulator" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">LightCurveSimulator</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Simulate blazar light curves as a random noise process.&quot;&quot;&quot;</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_total</span><span class="p">,</span> <span class="n">time_sampling</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an instance of LightCurveSimulator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        time_total : float</span>
<span class="sd">            Set the total time for the simulated data.</span>
<span class="sd">        time_sampling : float</span>
<span class="sd">            Set the time sampling for the simulated data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : LightCurveSimulator-instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">time_total</span> <span class="o">=</span> <span class="n">time_total</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_sampling</span> <span class="o">=</span> <span class="n">time_sampling</span>

        <span class="c1"># number of data points of the simulated data:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">time_total</span> <span class="o">/</span> <span class="n">time_sampling</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># create data time steps:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_timesteps</span><span class="p">()</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">set_time_sampling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_total</span><span class="p">,</span> <span class="n">time_sampling</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an instance of LightCurveSimulator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        time_total : float</span>
<span class="sd">            Set the total time for the simulated data.</span>
<span class="sd">        time_sampling : float</span>
<span class="sd">            Set the time sampling for the simulated data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">time_total</span> <span class="o">=</span> <span class="n">time_total</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_sampling</span> <span class="o">=</span> <span class="n">time_sampling</span>

        <span class="c1"># number of data points of the simulated data:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">time_total</span> <span class="o">/</span> <span class="n">time_sampling</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># create data time steps:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_timesteps</span><span class="p">()</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">suggest_time_sampling</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">10.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Suggests a total time and time sampling for simulated data, based on</span>
<span class="sd">        input time data. The total time is increased by a given factor, the</span>
<span class="sd">        time sampling reduced by the same factor, to include low and high</span>
<span class="sd">        frequency power in the simulated noise process.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        time : 1darray</span>
<span class="sd">            Time series.</span>
<span class="sd">        average : string, default=&#39;median&#39;</span>
<span class="sd">            Choose average type (&#39;median&#39; or &#39;mean&#39;) for suggested sampling.</span>
<span class="sd">        factor : float, default=10.</span>
<span class="sd">            The suggested total time and sampling are modified by this factor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out, out : float, float</span>
<span class="sd">            Suggested (minimum) total time and (maximum) sampling rate.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">total_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">deltat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">sampling_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">deltat</span><span class="p">)</span>
        <span class="n">sampling_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">deltat</span><span class="p">)</span>
        <span class="n">sampling_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">deltat</span><span class="p">)</span>
        <span class="n">sampling_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">deltat</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">average</span><span class="o">==</span><span class="s1">&#39;median&#39;</span><span class="p">:</span>
            <span class="n">sim_sampling</span> <span class="o">=</span> <span class="n">sampling_median</span> <span class="o">/</span> <span class="n">factor</span>
        <span class="k">elif</span> <span class="n">average</span><span class="o">==</span><span class="s1">&#39;mean&#39;</span><span class="p">:</span>
            <span class="n">sim_sampling</span> <span class="o">=</span> <span class="n">sampling_mean</span> <span class="o">/</span> <span class="n">factor</span>
        <span class="n">sim_total</span> <span class="o">=</span> <span class="n">total_time</span> <span class="o">*</span> <span class="n">factor</span>

        <span class="k">print</span> <span class="s1">&#39;Total time:         {0:8.3f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">total_time</span><span class="p">)</span>
        <span class="k">print</span> <span class="s1">&#39;Min. sampling:      {0:8.3f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampling_min</span><span class="p">)</span>
        <span class="k">print</span> <span class="s1">&#39;Max. sampling:      {0:8.3f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampling_max</span><span class="p">)</span>
        <span class="k">print</span> <span class="s1">&#39;Mean sampling:      {0:8.3f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampling_mean</span><span class="p">)</span>
        <span class="k">print</span> <span class="s1">&#39;Median sampling:    {0:8.3f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampling_median</span><span class="p">)</span>
        <span class="k">print</span> <span class="s1">&#39;Suggested&#39;</span>
        <span class="k">print</span> <span class="s1">&#39;Maximum sampling:   {0:8.3f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sim_sampling</span><span class="p">)</span>
        <span class="k">print</span> <span class="s1">&#39;Minimum total time: {0:8.3f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sim_total</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sim_total</span><span class="p">,</span> <span class="n">sim_sampling</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_create_timesteps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates time steps based on total time and time sampling.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># adjust total time:</span>
        <span class="n">time_total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_sampling</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">time_total</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndp</span><span class="p">)</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">powerlaw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an array of amplitudes following a power-law over the input</span>
<span class="sd">        frequencies.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        frequencies : 1darray</span>
<span class="sd">            Frequencies for which to calculate the power-law in arbitrary</span>
<span class="sd">            units.</span>
<span class="sd">        index : float, default=1.</span>
<span class="sd">            Power-law index.</span>
<span class="sd">        amplitude : float, default=10.</span>
<span class="sd">            Power-law amplitude at &#39;frequency&#39; in arbitrary unit.</span>
<span class="sd">        frequency : float, default=0.1</span>
<span class="sd">            Frequency for the given &#39;amplitude&#39; in same unit as &#39;frequencies&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : 1darray</span>
<span class="sd">            Array of same length as input &#39;frequencies&#39;.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Can be used as a generic shape for the power spectrum of a simulated</span>
<span class="sd">        light curve.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">/</span> <span class="n">frequency</span><span class="p">,</span> <span class="o">-</span><span class="n">index</span><span class="p">)</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">kneemodel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an array of amplitudes following a constant profile that</span>
<span class="sd">        changes into a power-law around a given frequency.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        frequencies : 1darray</span>
<span class="sd">            Frequencies for which to calculate the power-law in arbitrary</span>
<span class="sd">            units.</span>
<span class="sd">        index : float, default=1.</span>
<span class="sd">            Power-law index.</span>
<span class="sd">        amplitude : float, default=10.</span>
<span class="sd">            Constant amplitude at frequencies below &#39;frequency&#39; in arbitrary</span>
<span class="sd">            unit.</span>
<span class="sd">        frequency : float, default=0.1</span>
<span class="sd">            Frequency  in same unit as &#39;frequencies&#39; at which profile changes</span>
<span class="sd">            into a power-law.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : 1darray</span>
<span class="sd">            Array of same length as input &#39;frequencies&#39;.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Can be used as a generic shape for the power spectrum of a simulated</span>
<span class="sd">        light curve.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">/</span> <span class="n">frequency</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                                    <span class="o">-</span><span class="n">index</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">brokenpowerlaw</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="n">index_lo</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">index_hi</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span>
            <span class="n">frequency</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an array of amplitudes following a broken power-law.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        frequencies : array</span>
<span class="sd">            Frequencies for which to calculate the power-law in arbitrary units.</span>
<span class="sd">        index_hi : float, default=2.</span>
<span class="sd">            Power-law index at frequencies lower than &#39;frequency&#39;.</span>
<span class="sd">        index_lo : float, default=1.</span>
<span class="sd">            Power-law index at frequencies higher than &#39;frequency&#39;.</span>
<span class="sd">        frequency : float, default=0.1</span>
<span class="sd">            Frequency of the power-law break in same unit as &#39;frequencies&#39;.</span>
<span class="sd">        amplitude : float, default=10.</span>
<span class="sd">            Amplitude at &#39;frequency&#39; in arbitrary unit.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">            Array of same length as input &#39;frequencies&#39;.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Can be used as a generic shape for the power spectrum of a simulated</span>
<span class="sd">        light curve.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">frequencies</span> <span class="o">&gt;</span> <span class="n">frequency</span><span class="p">,</span>
                <span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">/</span> <span class="n">frequency</span><span class="p">,</span> <span class="o">-</span><span class="n">index_hi</span><span class="p">),</span>
                <span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">/</span> <span class="n">frequency</span><span class="p">,</span> <span class="o">-</span><span class="n">index_lo</span><span class="p">))</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">multi_logn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multi-component log-normal function.</span>

<span class="sd">        Returns the function values at position x.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------</span>
<span class="sd">        x : float or np.ndarray</span>
<span class="sd">            Function is evaluated at these positions.</span>
<span class="sd">        params : list</span>
<span class="sd">            Function parameters. For each log-normal component three</span>
<span class="sd">            parameters: peak position, peak amplitude, peak width. For multiple</span>
<span class="sd">            components append tripplets of these parameters (e.g.</span>
<span class="sd">            [pos1, amp1, wid1, pos2, amp2, wid2]).</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : float or np.ndarray</span>
<span class="sd">            Function evaluated at x.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Can be used as a generic shape for the probability density of a</span>
<span class="sd">        simulated light curve.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">),</span> <span class="mi">3</span><span class="p">):</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">amp</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">wid</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">amp</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span> <span class="o">/</span> <span class="n">wid</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">y</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_draw_from_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draws random number from a function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        func : function</span>
<span class="sd">            A function to draw random mumbers from.</span>
<span class="sd">        params : list</span>
<span class="sd">            The parameters of the PDF.</span>
<span class="sd">        x_min : float</span>
<span class="sd">            The minimum value to draw.</span>
<span class="sd">        x_min : float</span>
<span class="sd">            The maximum value to draw.</span>
<span class="sd">        size : int, default=1</span>
<span class="sd">            Number of random data points to return.</span>
<span class="sd">        seed : int, default=False</span>
<span class="sd">            Sets a seed for the random generator to get a reproducable result.</span>
<span class="sd">            For testing only.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : np.1darray</span>
<span class="sd">            Random numbers.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Can be used to draw random numbers from a probability density function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="n">pdf</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>
        <span class="n">cdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>
        <span class="n">cdf</span> <span class="o">/=</span> <span class="n">cdf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">seed</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">rand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">rand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">rand</span><span class="p">,</span> <span class="n">cdf</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rand</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_sim_tk</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">time_total</span><span class="p">,</span> <span class="n">time_sampling</span><span class="p">,</span> <span class="n">spec_shape</span><span class="p">,</span> <span class="n">spec_args</span><span class="p">,</span>
            <span class="n">seed</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function that is called by self.sim_tk().</span>

<span class="sd">        This function implements the Timmer &amp; Koenig, 1995 [1] algorithm for</span>
<span class="sd">        producing a single artificial light curve. See docstring of</span>
<span class="sd">        self.sim_tk() for details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        time_total : float</span>
<span class="sd">            Length of the simulation in arbitrary time unit.</span>
<span class="sd">        time_sampling : float</span>
<span class="sd">            Length of the sampling interval in same unit as &#39;time&#39;.</span>
<span class="sd">        spec_shape : func</span>
<span class="sd">            Function that takes an array of frequencies and &#39;spec_args&#39; as</span>
<span class="sd">            input and calculates a spectrum for those frequencies.</span>
<span class="sd">        spec_args : list</span>
<span class="sd">            Function arguments to &#39;spec_shape&#39;.</span>
<span class="sd">        seed : int, default=False</span>
<span class="sd">            Sets a seed for the random generator to get a reproducable result.</span>
<span class="sd">            For testing only.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : numpy.ndarray</span>
<span class="sd">            Simulated light curve following a random noise process with the</span>
<span class="sd">            input power spectrum.</span>

<span class="sd">        References</span>
<span class="sd">        -----</span>
<span class="sd">        [1] Timmer and Koenig, 1995, &#39;On generating power law noise&#39;, A&amp;A, 300,</span>
<span class="sd">            707</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get number of data points:</span>
        <span class="n">ndp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">time_total</span> <span class="o">/</span> <span class="n">time_sampling</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># set spectrum:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">ndp</span><span class="p">,</span> <span class="n">time_sampling</span><span class="p">)</span>
        <span class="n">freq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="n">spec_shape</span><span class="p">(</span><span class="n">freq</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="o">*</span><span class="n">spec_args</span><span class="p">)</span>
        <span class="n">spectrum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">del</span> <span class="n">freq</span>

        <span class="c1"># random (complex) Fourier coefficients for inverse Fourier transform:</span>
        <span class="k">if</span> <span class="n">seed</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="c1"># if N is even the Nyquist frequency is real:</span>
        <span class="k">if</span> <span class="n">ndp</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">coef</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c1"># complex coefficients:</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">coef</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1j</span> <span class="o">*</span> <span class="n">coef</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># scale coefficients with spectrum:</span>
        <span class="c1">#coef *= np.sqrt(0.5 * spectrum) # this is how it is defined in T&amp;K95</span>
        <span class="c1">#coef *= np.sqrt(0.5 * spectrum * ndp / sampling) # this is what I</span>
        <span class="c1"># used in PhD thesis</span>
        <span class="n">coef</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">spectrum</span> <span class="o">*</span> <span class="n">ndp</span><span class="p">)</span> <span class="c1"># this is what works to get</span>
        <span class="c1"># correct PSD slope, see argument in PhD notebook</span>
        <span class="c1"># 1.2_AmplitudeProblem.ipynb</span>
        <span class="n">coef</span> <span class="o">*=</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="n">spec_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">2.5</span><span class="p">)</span> <span class="c1"># this is an empirical scaling factor</span>
        <span class="c1"># to get the correct amplitude (approximately; would be better to</span>
        <span class="c1"># understand where this is coming from)</span>

        <span class="c1"># inverse Fourier transform:</span>
        <span class="n">lightcurve</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">coef</span><span class="p">,</span> <span class="n">ndp</span><span class="p">)</span>

        <span class="c1"># normalize to zero mean:</span>
        <span class="n">lightcurve</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">lightcurve</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lightcurve</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">sim_tk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec_shape</span><span class="p">,</span> <span class="n">spec_args</span><span class="p">,</span> <span class="n">nlcs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Simulates one/multiple equally sampled light curve(s) following a</span>
<span class="sd">        random noise process with given a spectral shape of the power spectral</span>
<span class="sd">        density [1].</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        spec_shape : func</span>
<span class="sd">            Function that takes an array of frequencies and &#39;spec_args&#39; as</span>
<span class="sd">            input and calculates a spectrum for those frequencies.</span>
<span class="sd">        spec_args : list</span>
<span class="sd">            Function arguments to &#39;spec_shape&#39;.</span>
<span class="sd">        nlcs : int, default=1</span>
<span class="sd">            Set the number of light curves that are produced. See notes below.</span>
<span class="sd">        seed : int, default=False</span>
<span class="sd">            Sets a seed for the random generator to get a reproducable result.</span>
<span class="sd">            For testing only.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The method will initially produce one long light curve with a total</span>
<span class="sd">        time N times longer than the final total time, where N is set by</span>
<span class="sd">        &#39;nlcs&#39;. This long light curve is then split into N individual pieces.</span>
<span class="sd">        Producing one initial long light curves means that power at frequencies</span>
<span class="sd">        N times lower than the final total time is included in the noise</span>
<span class="sd">        process. Setting ncls&gt;1 allows to include low-frequency power.</span>

<span class="sd">        References</span>
<span class="sd">        -----</span>
<span class="sd">        [1] Timmer and Koenig, 1995, &#39;On generating power law noise&#39;, A&amp;A, 300,</span>
<span class="sd">            707</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get total time of long light curve:</span>
        <span class="n">time_total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_sampling</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndp</span> <span class="o">*</span> <span class="n">nlcs</span>

        <span class="c1"># simulate long lightcurve:</span>
        <span class="n">lightcurve</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sim_tk</span><span class="p">(</span>
                <span class="n">time_total</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_sampling</span><span class="p">,</span> <span class="n">spec_shape</span><span class="p">,</span> <span class="n">spec_args</span><span class="p">,</span>
                <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">lightcurve</span> <span class="o">=</span> <span class="n">lightcurve</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># one light curve: store final data:</span>
        <span class="k">if</span> <span class="n">nlcs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span> <span class="o">=</span> <span class="p">[</span><span class="n">lightcurve</span><span class="p">]</span>

        <span class="c1"># multiple light curves: reshape to short light curves:</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">nlcs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndp</span><span class="p">)</span>
            <span class="n">lightcurves</span> <span class="o">=</span> <span class="n">lightcurve</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">ndp</span><span class="o">*</span><span class="n">nlcs</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">lc</span> <span class="ow">in</span> <span class="n">lightcurves</span><span class="p">:</span>
                <span class="c1"># normalize to zero mean:</span>
                <span class="n">lc</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lc_type</span> <span class="o">=</span> <span class="s1">&#39;TK&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lc_scale</span> <span class="o">=</span> <span class="s1">&#39;None&#39;</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_adjust_pdf</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">lightcurve</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">pdf_params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pdf_range</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">keep_non_converged</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function that is called by self.adjust_pdf().</span>

<span class="sd">        This function implements the Emmanoulopoulos et al, 2013 [1] algorithm</span>
<span class="sd">        for changing the PDF of a light curve while maintaining its PSD. See</span>
<span class="sd">        docstring of self.adjust_pdf() for details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        lightcurve : numpy.ndarray</span>
<span class="sd">            Flux density data of an evenly sampled light curve.</span>
<span class="sd">        pdf : numpy.ndarray or callable</span>
<span class="sd">            When providing flux data in a numpy.array the method will calculate</span>
<span class="sd">            an ECDF of the input data and draw random flux values from that</span>
<span class="sd">            ECDF.</span>
<span class="sd">            When providing a callable function the method will use that</span>
<span class="sd">            function to draw random flux values. Parameters for the function</span>
<span class="sd">            need to be provided in &#39;pdf_params&#39;</span>
<span class="sd">        pdf_params : list, default=None</span>
<span class="sd">            When a callable function is given to &#39;pdf&#39;, corresponding</span>
<span class="sd">            parameters need to be given to &#39;pdf_params&#39;.</span>
<span class="sd">        pdf_range : list</span>
<span class="sd">            List of two elements. Random flux values will be drawn from the</span>
<span class="sd">            given PDF between the two limits provided by &#39;pdf_range&#39;. Required</span>
<span class="sd">            only when a callable function is given to &#39;pdf&#39;. Does not have an</span>
<span class="sd">            effect, when a numpy.ndarray is given to &#39;pdf&#39;.</span>
<span class="sd">        iterations : int, default=100</span>
<span class="sd">            The algorithm [1] is iterative. This value sets a maximum number of</span>
<span class="sd">            iterations to avoid infinite loops.</span>
<span class="sd">        keep_non_converged : bool or str, default=False</span>
<span class="sd">            If True the result is returned even if the algorithm [1] did not</span>
<span class="sd">            converge.</span>
<span class="sd">            If False and the algorithm [1] did not converge, False is returned.</span>
<span class="sd">            If set to &#39;ask&#39;, a notification is written asking how to proceed.</span>
<span class="sd">        threshold : float, default=0.01</span>
<span class="sd">            Defines when the algorithm [1] is considered as converged.</span>
<span class="sd">            Iterations are stopped when maximum difference between the current</span>
<span class="sd">            and the previous light curve does not exceed this &#39;threshold&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : numpy.ndarray</span>
<span class="sd">            Simulated light curve with the target PDF.</span>

<span class="sd">        References</span>
<span class="sd">        -----</span>
<span class="sd">        [1] Emmanoulopoulos et al, 2013, MNRAS, 433, 907</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># discrete Fourier transform:</span>
        <span class="n">dft_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">lightcurve</span><span class="p">)</span>
        <span class="n">ampl_adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">dft_norm</span><span class="p">)</span>

        <span class="c1"># create artificial light curve based on ECDF of input data:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">ecdf</span> <span class="o">=</span> <span class="n">ECDF</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>
            <span class="n">lc_sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">ecdf</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ndp</span><span class="p">),</span>
                               <span class="n">ecdf</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">ecdf</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># or create artificial light curve based on model PDF:</span>
        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">pdf</span><span class="p">):</span>
            <span class="n">lc_sim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_draw_from_func</span><span class="p">(</span>
                    <span class="n">pdf</span><span class="p">,</span> <span class="n">pdf_params</span><span class="p">,</span> <span class="n">pdf_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pdf_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ndp</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;&#39;pdf&#39; needs to be a np.ndarray or a function.&quot;</span><span class="p">)</span>

        <span class="c1"># iteration:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
            <span class="c1"># calculate DFT, amplitudes:</span>
            <span class="n">dft_sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">lc_sim</span><span class="p">)</span>
            <span class="n">ampl_sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">dft_sim</span><span class="p">)</span>

            <span class="c1"># spectral adjustment:</span>
            <span class="n">dft_adj</span> <span class="o">=</span> <span class="n">dft_sim</span> <span class="o">/</span> <span class="n">ampl_sim</span> <span class="o">*</span> <span class="n">ampl_adj</span>
            <span class="n">lc_adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">dft_adj</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ndp</span><span class="p">)</span>

            <span class="c1"># amplitude adjustment:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">lc_adj</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">lc_sim</span><span class="p">)</span>
            <span class="n">lc_adj</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">lc_sim</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>

            <span class="c1"># check if process converged:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">lc_adj</span> <span class="o">-</span><span class="n">lc_sim</span><span class="p">)</span> <span class="o">/</span> <span class="n">lc_sim</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lc_sim</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">lc_adj</span><span class="p">)</span>

        <span class="c1"># no convergence reached:</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ask what to do:</span>
            <span class="k">if</span> <span class="n">keep_non_converged</span> <span class="o">==</span> <span class="s1">&#39;ask&#39;</span><span class="p">:</span>
                <span class="n">inp</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">(</span>
                        <span class="s1">&#39;No convergence reached within {0:d} iterations. &#39;</span> \
                        <span class="s1">&#39;Keep (y), throw away (n), or try again (r)?&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">iterations</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">inp</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="n">inp</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>
                    <span class="n">lc_sim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjust_pdf</span><span class="p">(</span>
                            <span class="n">lightcurve</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">pdf_params</span><span class="o">=</span><span class="n">pdf_params</span><span class="p">,</span>
                            <span class="n">pdf_range</span><span class="o">=</span><span class="n">pdf_range</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span>
                            <span class="n">keep_non_converged</span><span class="o">=</span><span class="n">keep_non_converged</span><span class="p">,</span>
                            <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lc_sim</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="c1"># keep result anyway:</span>
            <span class="k">elif</span> <span class="n">keep_non_converged</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="c1"># return False:</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lc_sim</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">return</span> <span class="n">lc_sim</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">adjust_pdf</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">pdf_params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pdf_range</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
            <span class="n">keep_non_converged</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change the PDF of all simulated light curves to a target PDF.</span>

<span class="sd">        This method implements the Emmanoulopoulos et al, 2013 [1] algorithm</span>
<span class="sd">        for changing the PDF of a light curve while maintaining its PSD. This</span>
<span class="sd">        routine is automatically applied to all simulated light curves stored</span>
<span class="sd">        in the an LightCurveSimulator-instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        pdf : numpy.ndarray or callable</span>
<span class="sd">            When providing flux data in a numpy.array the method will calculate</span>
<span class="sd">            an ECDF of the input data and draw random flux values from that</span>
<span class="sd">            ECDF.</span>
<span class="sd">            When providing a callable function the method will use that</span>
<span class="sd">            function to draw random flux values. Parameters for the function</span>
<span class="sd">            need to be provided in &#39;pdf_params&#39;</span>
<span class="sd">        pdf_params : list, default=None</span>
<span class="sd">            When a callable function is given to &#39;pdf&#39;, corresponding</span>
<span class="sd">            parameters need to be given to &#39;pdf_params&#39;.</span>
<span class="sd">        pdf_range : list</span>
<span class="sd">            List of two elements. Random flux values will be drawn from the</span>
<span class="sd">            given PDF between the two limits provided by &#39;pdf_range&#39;. Required</span>
<span class="sd">            only when a callable function is given to &#39;pdf&#39;. Does not have an</span>
<span class="sd">            effect, when a numpy.ndarray is given to &#39;pdf&#39;.</span>
<span class="sd">        iterations : int, default=100</span>
<span class="sd">            The algorithm [1] is iterative. This value sets a maximum number of</span>
<span class="sd">            iterations to avoid infinite loops.</span>
<span class="sd">        keep_non_converged : bool or str, default=False</span>
<span class="sd">            If True the result is returned even if the algorithm [1] did not</span>
<span class="sd">            converge.</span>
<span class="sd">            If False and the algorithm [1] did not converge, False is returned.</span>
<span class="sd">            If set to &#39;ask&#39;, a notification is written asking how to proceed.</span>
<span class="sd">        threshold : float, default=0.01</span>
<span class="sd">            Defines when the algorithm [1] is considered as converged.</span>
<span class="sd">            Iterations are stopped when maximum difference between the current</span>
<span class="sd">            and the previous light curve does not exceed this &#39;threshold&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        None</span>

<span class="sd">        References</span>
<span class="sd">        -----</span>
<span class="sd">        [1] Emmanoulopoulos et al, 2013, MNRAS, 433, 907</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check that the PDFs have not been adjusted yet:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lc_type</span> <span class="o">==</span> <span class="s1">&#39;EMP&#39;</span><span class="p">:</span>
            <span class="k">print</span> <span class="s1">&#39;Light curve PDFs have already been adjusted. &#39;</span> \
                  <span class="s1">&#39;adjust_pdf() aborted!&#39;</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c1"># iterate through light curves:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span><span class="p">):</span>
            <span class="n">lc_adj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjust_pdf</span><span class="p">(</span>
                    <span class="n">lc</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">pdf_params</span><span class="o">=</span><span class="n">pdf_params</span><span class="p">,</span> <span class="n">pdf_range</span><span class="o">=</span><span class="n">pdf_range</span><span class="p">,</span>
                    <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span>
                    <span class="n">keep_non_converged</span><span class="o">=</span><span class="n">keep_non_converged</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lc_adj</span>

        <span class="c1"># remove non-converged light curves:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span> <span class="o">=</span> <span class="p">[</span><span class="n">lc</span> <span class="k">for</span> <span class="n">lc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span> <span class="k">if</span> <span class="n">lc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lc_type</span> <span class="o">=</span> <span class="s1">&#39;EMP&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">ECDF</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lc_scale</span> <span class="o">=</span> <span class="s1">&#39;ECDF&#39;</span>
        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">pdf</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lc_scale</span> <span class="o">=</span> <span class="s1">&#39;PDF&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lc_scale</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">sim_emp</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spec_shape</span><span class="p">,</span> <span class="n">spec_args</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">pdf_params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pdf_range</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">nlcs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  <span class="n">iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">keep_non_converged</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a simulated light curve with a specified PSD and PDF.</span>

<span class="sd">        This method combines the two steps of producting a Gaussian light curve</span>
<span class="sd">        with a given PSD [1] and adjusting its PDF to a specified PDF [2].</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        spec_shape : func</span>
<span class="sd">            Function that takes an array of frequencies and &#39;spec_args&#39; as</span>
<span class="sd">            input and calculates a spectrum for those frequencies.</span>
<span class="sd">        spec_args : list</span>
<span class="sd">            Function arguments to &#39;spec_shape&#39;.</span>
<span class="sd">        pdf : numpy.ndarray or callable</span>
<span class="sd">            When providing flux data in a numpy.array the method will calculate</span>
<span class="sd">            an ECDF of the input data and draw random flux values from that</span>
<span class="sd">            ECDF.</span>
<span class="sd">            When providing a callable function the method will use that</span>
<span class="sd">            function to draw random flux values. Parameters for the function</span>
<span class="sd">            need to be provided in &#39;pdf_params&#39;</span>
<span class="sd">        pdf_params : list, default=None</span>
<span class="sd">            When a callable function is given to &#39;pdf&#39;, corresponding</span>
<span class="sd">            parameters need to be given to &#39;pdf_params&#39;.</span>
<span class="sd">        pdf_range : list</span>
<span class="sd">            List of two elements. Random flux values will be drawn from the</span>
<span class="sd">            given PDF between the two limits provided by &#39;pdf_range&#39;. Required</span>
<span class="sd">            only when a callable function is given to &#39;pdf&#39;. Does not have an</span>
<span class="sd">            effect, when a numpy.ndarray is given to &#39;pdf&#39;.</span>
<span class="sd">        nlcs : int, default=1</span>
<span class="sd">            Set the number of light curves that are produced. See notes below.</span>
<span class="sd">        iterations : int, default=100</span>
<span class="sd">            The algorithm [1] is iterative. This value sets a maximum number of</span>
<span class="sd">            iterations to avoid infinite loops.</span>
<span class="sd">        keep_non_converged : bool or str, default=False</span>
<span class="sd">            If True the result is returned even if the algorithm [1] did not</span>
<span class="sd">            converge.</span>
<span class="sd">            If False and the algorithm [1] did not converge, False is returned.</span>
<span class="sd">            If set to &#39;ask&#39;, a notification is written asking how to proceed.</span>
<span class="sd">        threshold : float, default=0.01</span>
<span class="sd">            Defines when the algorithm [1] is considered as converged.</span>
<span class="sd">            Iterations are stopped when maximum difference between the current</span>
<span class="sd">            and the previous light curve does not exceed this &#39;threshold&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The method will initially produce one long Gaussian light curve with a</span>
<span class="sd">        total time N times longer than the final total time, where N is set by</span>
<span class="sd">        &#39;nlcs&#39;. This long light curve is then split into N individual pieces.</span>
<span class="sd">        Producing one initial long light curves means that power at frequencies</span>
<span class="sd">        N times lower than the final total time is included in the noise</span>
<span class="sd">        process. Setting ncls&gt;1 allows to include low-frequency power.</span>
<span class="sd">        The adjustment of the PDF is then applied to every split light curve</span>
<span class="sd">        individually.</span>

<span class="sd">        References</span>
<span class="sd">        -----</span>
<span class="sd">        [1] Timmer and Koenig, 1995, &#39;On generating power law noise&#39;, A&amp;A, 300,</span>
<span class="sd">            707</span>
<span class="sd">        [2] Emmanoulopoulos et al, 2013, MNRAS, 433, 907</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sim_tk</span><span class="p">(</span><span class="n">spec_shape</span><span class="p">,</span> <span class="n">spec_args</span><span class="p">,</span> <span class="n">nlcs</span><span class="o">=</span><span class="n">nlcs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adjust_pdf</span><span class="p">(</span>
                <span class="n">pdf</span><span class="p">,</span> <span class="n">pdf_params</span><span class="o">=</span><span class="n">pdf_params</span><span class="p">,</span> <span class="n">pdf_range</span><span class="o">=</span><span class="n">pdf_range</span><span class="p">,</span>
                <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span> <span class="n">keep_non_converged</span><span class="o">=</span><span class="n">keep_non_converged</span><span class="p">,</span>
                <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>

    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">get_lcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the simulated light curves.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -----</span>
<span class="sd">        out : list</span>
<span class="sd">            List of simulated light curves, each an ArtificialLightCurve</span>
<span class="sd">            instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">ArtificialLightCurve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lc_type</span><span class="p">)</span> \
               <span class="k">for</span> <span class="n">flux</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">lcs</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#lcsim.LightCurveSimulator">LightCurveSimulator</a></li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="lcsim.LightCurveSimulator.suggest_time_sampling">
    <p>def <span class="ident">suggest_time_sampling</span>(</p><p>time, average=&#39;median&#39;, factor=10.0)</p>
    </div>
    

    
  
    <div class="desc"><p>Suggests a total time and time sampling for simulated data, based on
input time data. The total time is increased by a given factor, the
time sampling reduced by the same factor, to include low and high
frequency power in the simulated noise process.</p>
<h2>Parameters</h2>
<p>time : 1darray
    Time series.
average : string, default='median'
    Choose average type ('median' or 'mean') for suggested sampling.
factor : float, default=10.
    The suggested total time and sampling are modified by this factor.</p>
<h2>Returns</h2>
<p>out, out : float, float
    Suggested (minimum) total time and (maximum) sampling rate.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-lcsim.LightCurveSimulator.suggest_time_sampling', this);">Show source &equiv;</a></p>
  <div id="source-lcsim.LightCurveSimulator.suggest_time_sampling" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">suggest_time_sampling</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">10.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Suggests a total time and time sampling for simulated data, based on</span>
<span class="sd">    input time data. The total time is increased by a given factor, the</span>
<span class="sd">    time sampling reduced by the same factor, to include low and high</span>
<span class="sd">    frequency power in the simulated noise process.</span>
<span class="sd">    Parameters</span>
<span class="sd">    -----</span>
<span class="sd">    time : 1darray</span>
<span class="sd">        Time series.</span>
<span class="sd">    average : string, default=&#39;median&#39;</span>
<span class="sd">        Choose average type (&#39;median&#39; or &#39;mean&#39;) for suggested sampling.</span>
<span class="sd">    factor : float, default=10.</span>
<span class="sd">        The suggested total time and sampling are modified by this factor.</span>
<span class="sd">    Returns</span>
<span class="sd">    -----</span>
<span class="sd">    out, out : float, float</span>
<span class="sd">        Suggested (minimum) total time and (maximum) sampling rate.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">total_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">deltat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">sampling_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">deltat</span><span class="p">)</span>
    <span class="n">sampling_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">deltat</span><span class="p">)</span>
    <span class="n">sampling_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">deltat</span><span class="p">)</span>
    <span class="n">sampling_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">deltat</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">average</span><span class="o">==</span><span class="s1">&#39;median&#39;</span><span class="p">:</span>
        <span class="n">sim_sampling</span> <span class="o">=</span> <span class="n">sampling_median</span> <span class="o">/</span> <span class="n">factor</span>
    <span class="k">elif</span> <span class="n">average</span><span class="o">==</span><span class="s1">&#39;mean&#39;</span><span class="p">:</span>
        <span class="n">sim_sampling</span> <span class="o">=</span> <span class="n">sampling_mean</span> <span class="o">/</span> <span class="n">factor</span>
    <span class="n">sim_total</span> <span class="o">=</span> <span class="n">total_time</span> <span class="o">*</span> <span class="n">factor</span>
    <span class="k">print</span> <span class="s1">&#39;Total time:         {0:8.3f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">total_time</span><span class="p">)</span>
    <span class="k">print</span> <span class="s1">&#39;Min. sampling:      {0:8.3f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampling_min</span><span class="p">)</span>
    <span class="k">print</span> <span class="s1">&#39;Max. sampling:      {0:8.3f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampling_max</span><span class="p">)</span>
    <span class="k">print</span> <span class="s1">&#39;Mean sampling:      {0:8.3f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampling_mean</span><span class="p">)</span>
    <span class="k">print</span> <span class="s1">&#39;Median sampling:    {0:8.3f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampling_median</span><span class="p">)</span>
    <span class="k">print</span> <span class="s1">&#39;Suggested&#39;</span>
    <span class="k">print</span> <span class="s1">&#39;Maximum sampling:   {0:8.3f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sim_sampling</span><span class="p">)</span>
    <span class="k">print</span> <span class="s1">&#39;Minimum total time: {0:8.3f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sim_total</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sim_total</span><span class="p">,</span> <span class="n">sim_sampling</span>
</pre></div>

  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="lcsim.LightCurveSimulator.ndp" class="name">var <span class="ident">ndp</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="lcsim.LightCurveSimulator.time_sampling" class="name">var <span class="ident">time_sampling</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="lcsim.LightCurveSimulator.time_total" class="name">var <span class="ident">time_total</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="lcsim.LightCurveSimulator.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, time_total, time_sampling)</p>
    </div>
    

    
  
    <div class="desc"><p>Create an instance of LightCurveSimulator.</p>
<h2>Parameters</h2>
<p>time_total : float
    Set the total time for the simulated data.
time_sampling : float
    Set the time sampling for the simulated data.</p>
<h2>Returns</h2>
<p>out : LightCurveSimulator-instance</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-lcsim.LightCurveSimulator.__init__', this);">Show source &equiv;</a></p>
  <div id="source-lcsim.LightCurveSimulator.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_total</span><span class="p">,</span> <span class="n">time_sampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create an instance of LightCurveSimulator.</span>
<span class="sd">    Parameters</span>
<span class="sd">    -----</span>
<span class="sd">    time_total : float</span>
<span class="sd">        Set the total time for the simulated data.</span>
<span class="sd">    time_sampling : float</span>
<span class="sd">        Set the time sampling for the simulated data.</span>
<span class="sd">    Returns</span>
<span class="sd">    -----</span>
<span class="sd">    out : LightCurveSimulator-instance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">time_total</span> <span class="o">=</span> <span class="n">time_total</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">time_sampling</span> <span class="o">=</span> <span class="n">time_sampling</span>
    <span class="c1"># number of data points of the simulated data:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ndp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">time_total</span> <span class="o">/</span> <span class="n">time_sampling</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="c1"># create data time steps:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_create_timesteps</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="lcsim.LightCurveSimulator.adjust_pdf">
    <p>def <span class="ident">adjust_pdf</span>(</p><p>self, pdf, pdf_params=None, pdf_range=None, iterations=100, keep_non_converged=False, threshold=0.01)</p>
    </div>
    

    
  
    <div class="desc"><p>Change the PDF of all simulated light curves to a target PDF.</p>
<p>This method implements the Emmanoulopoulos et al, 2013 [1] algorithm
for changing the PDF of a light curve while maintaining its PSD. This
routine is automatically applied to all simulated light curves stored
in the an LightCurveSimulator-instance.</p>
<h2>Parameters</h2>
<p>pdf : numpy.ndarray or callable
    When providing flux data in a numpy.array the method will calculate
    an ECDF of the input data and draw random flux values from that
    ECDF.
    When providing a callable function the method will use that
    function to draw random flux values. Parameters for the function
    need to be provided in 'pdf_params'
pdf_params : list, default=None
    When a callable function is given to 'pdf', corresponding
    parameters need to be given to 'pdf_params'.
pdf_range : list
    List of two elements. Random flux values will be drawn from the
    given PDF between the two limits provided by 'pdf_range'. Required
    only when a callable function is given to 'pdf'. Does not have an
    effect, when a numpy.ndarray is given to 'pdf'.
iterations : int, default=100
    The algorithm [1] is iterative. This value sets a maximum number of
    iterations to avoid infinite loops.
keep_non_converged : bool or str, default=False
    If True the result is returned even if the algorithm [1] did not
    converge.
    If False and the algorithm [1] did not converge, False is returned.
    If set to 'ask', a notification is written asking how to proceed.
threshold : float, default=0.01
    Defines when the algorithm [1] is considered as converged.
    Iterations are stopped when maximum difference between the current
    and the previous light curve does not exceed this 'threshold'.</p>
<h2>Returns</h2>
<p>None</p>
<h2>References</h2>
<p>[1] Emmanoulopoulos et al, 2013, MNRAS, 433, 907</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-lcsim.LightCurveSimulator.adjust_pdf', this);">Show source &equiv;</a></p>
  <div id="source-lcsim.LightCurveSimulator.adjust_pdf" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">adjust_pdf</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">pdf_params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pdf_range</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">keep_non_converged</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Change the PDF of all simulated light curves to a target PDF.</span>
<span class="sd">    This method implements the Emmanoulopoulos et al, 2013 [1] algorithm</span>
<span class="sd">    for changing the PDF of a light curve while maintaining its PSD. This</span>
<span class="sd">    routine is automatically applied to all simulated light curves stored</span>
<span class="sd">    in the an LightCurveSimulator-instance.</span>
<span class="sd">    Parameters</span>
<span class="sd">    -----</span>
<span class="sd">    pdf : numpy.ndarray or callable</span>
<span class="sd">        When providing flux data in a numpy.array the method will calculate</span>
<span class="sd">        an ECDF of the input data and draw random flux values from that</span>
<span class="sd">        ECDF.</span>
<span class="sd">        When providing a callable function the method will use that</span>
<span class="sd">        function to draw random flux values. Parameters for the function</span>
<span class="sd">        need to be provided in &#39;pdf_params&#39;</span>
<span class="sd">    pdf_params : list, default=None</span>
<span class="sd">        When a callable function is given to &#39;pdf&#39;, corresponding</span>
<span class="sd">        parameters need to be given to &#39;pdf_params&#39;.</span>
<span class="sd">    pdf_range : list</span>
<span class="sd">        List of two elements. Random flux values will be drawn from the</span>
<span class="sd">        given PDF between the two limits provided by &#39;pdf_range&#39;. Required</span>
<span class="sd">        only when a callable function is given to &#39;pdf&#39;. Does not have an</span>
<span class="sd">        effect, when a numpy.ndarray is given to &#39;pdf&#39;.</span>
<span class="sd">    iterations : int, default=100</span>
<span class="sd">        The algorithm [1] is iterative. This value sets a maximum number of</span>
<span class="sd">        iterations to avoid infinite loops.</span>
<span class="sd">    keep_non_converged : bool or str, default=False</span>
<span class="sd">        If True the result is returned even if the algorithm [1] did not</span>
<span class="sd">        converge.</span>
<span class="sd">        If False and the algorithm [1] did not converge, False is returned.</span>
<span class="sd">        If set to &#39;ask&#39;, a notification is written asking how to proceed.</span>
<span class="sd">    threshold : float, default=0.01</span>
<span class="sd">        Defines when the algorithm [1] is considered as converged.</span>
<span class="sd">        Iterations are stopped when maximum difference between the current</span>
<span class="sd">        and the previous light curve does not exceed this &#39;threshold&#39;.</span>
<span class="sd">    Returns</span>
<span class="sd">    -----</span>
<span class="sd">    None</span>
<span class="sd">    References</span>
<span class="sd">    -----</span>
<span class="sd">    [1] Emmanoulopoulos et al, 2013, MNRAS, 433, 907</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># check that the PDFs have not been adjusted yet:</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lc_type</span> <span class="o">==</span> <span class="s1">&#39;EMP&#39;</span><span class="p">:</span>
        <span class="k">print</span> <span class="s1">&#39;Light curve PDFs have already been adjusted. &#39;</span> \
              <span class="s1">&#39;adjust_pdf() aborted!&#39;</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="c1"># iterate through light curves:</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span><span class="p">):</span>
        <span class="n">lc_adj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjust_pdf</span><span class="p">(</span>
                <span class="n">lc</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">pdf_params</span><span class="o">=</span><span class="n">pdf_params</span><span class="p">,</span> <span class="n">pdf_range</span><span class="o">=</span><span class="n">pdf_range</span><span class="p">,</span>
                <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span>
                <span class="n">keep_non_converged</span><span class="o">=</span><span class="n">keep_non_converged</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lc_adj</span>
    <span class="c1"># remove non-converged light curves:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span> <span class="o">=</span> <span class="p">[</span><span class="n">lc</span> <span class="k">for</span> <span class="n">lc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span> <span class="k">if</span> <span class="n">lc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lc_type</span> <span class="o">=</span> <span class="s1">&#39;EMP&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">ECDF</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lc_scale</span> <span class="o">=</span> <span class="s1">&#39;ECDF&#39;</span>
    <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">pdf</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lc_scale</span> <span class="o">=</span> <span class="s1">&#39;PDF&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lc_scale</span> <span class="o">=</span> <span class="bp">False</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="lcsim.LightCurveSimulator.brokenpowerlaw">
    <p>def <span class="ident">brokenpowerlaw</span>(</p><p>self, frequencies, index_lo=1.0, index_hi=2.0, amplitude=10.0, frequency=0.1)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns an array of amplitudes following a broken power-law.</p>
<h2>Parameters</h2>
<p>frequencies : array
    Frequencies for which to calculate the power-law in arbitrary units.
index_hi : float, default=2.
    Power-law index at frequencies lower than 'frequency'.
index_lo : float, default=1.
    Power-law index at frequencies higher than 'frequency'.
frequency : float, default=0.1
    Frequency of the power-law break in same unit as 'frequencies'.
amplitude : float, default=10.
    Amplitude at 'frequency' in arbitrary unit.</p>
<h2>Returns</h2>
<div class="codehilite"><pre><span></span>Array of same length as input &#39;frequencies&#39;.
</pre></div>


<h2>Notes</h2>
<p>Can be used as a generic shape for the power spectrum of a simulated
light curve.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-lcsim.LightCurveSimulator.brokenpowerlaw', this);">Show source &equiv;</a></p>
  <div id="source-lcsim.LightCurveSimulator.brokenpowerlaw" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">brokenpowerlaw</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="n">index_lo</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">index_hi</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span>
        <span class="n">frequency</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns an array of amplitudes following a broken power-law.</span>
<span class="sd">    Parameters</span>
<span class="sd">    -----</span>
<span class="sd">    frequencies : array</span>
<span class="sd">        Frequencies for which to calculate the power-law in arbitrary units.</span>
<span class="sd">    index_hi : float, default=2.</span>
<span class="sd">        Power-law index at frequencies lower than &#39;frequency&#39;.</span>
<span class="sd">    index_lo : float, default=1.</span>
<span class="sd">        Power-law index at frequencies higher than &#39;frequency&#39;.</span>
<span class="sd">    frequency : float, default=0.1</span>
<span class="sd">        Frequency of the power-law break in same unit as &#39;frequencies&#39;.</span>
<span class="sd">    amplitude : float, default=10.</span>
<span class="sd">        Amplitude at &#39;frequency&#39; in arbitrary unit.</span>
<span class="sd">    Returns</span>
<span class="sd">    -----</span>
<span class="sd">        Array of same length as input &#39;frequencies&#39;.</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Can be used as a generic shape for the power spectrum of a simulated</span>
<span class="sd">    light curve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">frequencies</span> <span class="o">&gt;</span> <span class="n">frequency</span><span class="p">,</span>
            <span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">/</span> <span class="n">frequency</span><span class="p">,</span> <span class="o">-</span><span class="n">index_hi</span><span class="p">),</span>
            <span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">/</span> <span class="n">frequency</span><span class="p">,</span> <span class="o">-</span><span class="n">index_lo</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="lcsim.LightCurveSimulator.get_lcs">
    <p>def <span class="ident">get_lcs</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the simulated light curves.</p>
<h2>Parameters</h2>
<p>None</p>
<h2>Returns</h2>
<p>out : list
    List of simulated light curves, each an ArtificialLightCurve
    instance.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-lcsim.LightCurveSimulator.get_lcs', this);">Show source &equiv;</a></p>
  <div id="source-lcsim.LightCurveSimulator.get_lcs" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_lcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the simulated light curves.</span>
<span class="sd">    Parameters</span>
<span class="sd">    -----</span>
<span class="sd">    None</span>
<span class="sd">    Returns</span>
<span class="sd">    -----</span>
<span class="sd">    out : list</span>
<span class="sd">        List of simulated light curves, each an ArtificialLightCurve</span>
<span class="sd">        instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">ArtificialLightCurve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lc_type</span><span class="p">)</span> \
           <span class="k">for</span> <span class="n">flux</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">lcs</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="lcsim.LightCurveSimulator.kneemodel">
    <p>def <span class="ident">kneemodel</span>(</p><p>self, frequencies, index=1.0, amplitude=10.0, frequency=0.1)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns an array of amplitudes following a constant profile that
changes into a power-law around a given frequency.</p>
<h2>Parameters</h2>
<p>frequencies : 1darray
    Frequencies for which to calculate the power-law in arbitrary
    units.
index : float, default=1.
    Power-law index.
amplitude : float, default=10.
    Constant amplitude at frequencies below 'frequency' in arbitrary
    unit.
frequency : float, default=0.1
    Frequency  in same unit as 'frequencies' at which profile changes
    into a power-law.</p>
<h2>Returns</h2>
<p>out : 1darray
    Array of same length as input 'frequencies'.</p>
<h2>Notes</h2>
<p>Can be used as a generic shape for the power spectrum of a simulated
light curve.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-lcsim.LightCurveSimulator.kneemodel', this);">Show source &equiv;</a></p>
  <div id="source-lcsim.LightCurveSimulator.kneemodel" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">kneemodel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns an array of amplitudes following a constant profile that</span>
<span class="sd">    changes into a power-law around a given frequency.</span>
<span class="sd">    Parameters</span>
<span class="sd">    -----</span>
<span class="sd">    frequencies : 1darray</span>
<span class="sd">        Frequencies for which to calculate the power-law in arbitrary</span>
<span class="sd">        units.</span>
<span class="sd">    index : float, default=1.</span>
<span class="sd">        Power-law index.</span>
<span class="sd">    amplitude : float, default=10.</span>
<span class="sd">        Constant amplitude at frequencies below &#39;frequency&#39; in arbitrary</span>
<span class="sd">        unit.</span>
<span class="sd">    frequency : float, default=0.1</span>
<span class="sd">        Frequency  in same unit as &#39;frequencies&#39; at which profile changes</span>
<span class="sd">        into a power-law.</span>
<span class="sd">    Returns</span>
<span class="sd">    -----</span>
<span class="sd">    out : 1darray</span>
<span class="sd">        Array of same length as input &#39;frequencies&#39;.</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Can be used as a generic shape for the power spectrum of a simulated</span>
<span class="sd">    light curve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">/</span> <span class="n">frequency</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                                <span class="o">-</span><span class="n">index</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="lcsim.LightCurveSimulator.multi_logn">
    <p>def <span class="ident">multi_logn</span>(</p><p>self, x, *params)</p>
    </div>
    

    
  
    <div class="desc"><p>Multi-component log-normal function.</p>
<p>Returns the function values at position x.</p>
<h2>Parameters</h2>
<p>x : float or np.ndarray
    Function is evaluated at these positions.
params : list
    Function parameters. For each log-normal component three
    parameters: peak position, peak amplitude, peak width. For multiple
    components append tripplets of these parameters (e.g.
    [pos1, amp1, wid1, pos2, amp2, wid2]).</p>
<h2>Returns</h2>
<p>out : float or np.ndarray
    Function evaluated at x.</p>
<h2>Notes</h2>
<p>Can be used as a generic shape for the probability density of a
simulated light curve.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-lcsim.LightCurveSimulator.multi_logn', this);">Show source &equiv;</a></p>
  <div id="source-lcsim.LightCurveSimulator.multi_logn" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">multi_logn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Multi-component log-normal function.</span>
<span class="sd">    Returns the function values at position x.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ------</span>
<span class="sd">    x : float or np.ndarray</span>
<span class="sd">        Function is evaluated at these positions.</span>
<span class="sd">    params : list</span>
<span class="sd">        Function parameters. For each log-normal component three</span>
<span class="sd">        parameters: peak position, peak amplitude, peak width. For multiple</span>
<span class="sd">        components append tripplets of these parameters (e.g.</span>
<span class="sd">        [pos1, amp1, wid1, pos2, amp2, wid2]).</span>
<span class="sd">    Returns</span>
<span class="sd">    -----</span>
<span class="sd">    out : float or np.ndarray</span>
<span class="sd">        Function evaluated at x.</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Can be used as a generic shape for the probability density of a</span>
<span class="sd">    simulated light curve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">),</span> <span class="mi">3</span><span class="p">):</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">amp</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">wid</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">amp</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span> <span class="o">/</span> <span class="n">wid</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="lcsim.LightCurveSimulator.powerlaw">
    <p>def <span class="ident">powerlaw</span>(</p><p>self, frequencies, index=1.0, amplitude=10.0, frequency=0.1)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns an array of amplitudes following a power-law over the input
frequencies.</p>
<h2>Parameters</h2>
<p>frequencies : 1darray
    Frequencies for which to calculate the power-law in arbitrary
    units.
index : float, default=1.
    Power-law index.
amplitude : float, default=10.
    Power-law amplitude at 'frequency' in arbitrary unit.
frequency : float, default=0.1
    Frequency for the given 'amplitude' in same unit as 'frequencies'.</p>
<h2>Returns</h2>
<p>out : 1darray
    Array of same length as input 'frequencies'.</p>
<h2>Notes</h2>
<p>Can be used as a generic shape for the power spectrum of a simulated
light curve.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-lcsim.LightCurveSimulator.powerlaw', this);">Show source &equiv;</a></p>
  <div id="source-lcsim.LightCurveSimulator.powerlaw" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">powerlaw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns an array of amplitudes following a power-law over the input</span>
<span class="sd">    frequencies.</span>
<span class="sd">    Parameters</span>
<span class="sd">    -----</span>
<span class="sd">    frequencies : 1darray</span>
<span class="sd">        Frequencies for which to calculate the power-law in arbitrary</span>
<span class="sd">        units.</span>
<span class="sd">    index : float, default=1.</span>
<span class="sd">        Power-law index.</span>
<span class="sd">    amplitude : float, default=10.</span>
<span class="sd">        Power-law amplitude at &#39;frequency&#39; in arbitrary unit.</span>
<span class="sd">    frequency : float, default=0.1</span>
<span class="sd">        Frequency for the given &#39;amplitude&#39; in same unit as &#39;frequencies&#39;.</span>
<span class="sd">    Returns</span>
<span class="sd">    -----</span>
<span class="sd">    out : 1darray</span>
<span class="sd">        Array of same length as input &#39;frequencies&#39;.</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Can be used as a generic shape for the power spectrum of a simulated</span>
<span class="sd">    light curve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">/</span> <span class="n">frequency</span><span class="p">,</span> <span class="o">-</span><span class="n">index</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="lcsim.LightCurveSimulator.set_time_sampling">
    <p>def <span class="ident">set_time_sampling</span>(</p><p>self, time_total, time_sampling)</p>
    </div>
    

    
  
    <div class="desc"><p>Create an instance of LightCurveSimulator.</p>
<h2>Parameters</h2>
<p>time_total : float
    Set the total time for the simulated data.
time_sampling : float
    Set the time sampling for the simulated data.</p>
<h2>Returns</h2>
<p>None</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-lcsim.LightCurveSimulator.set_time_sampling', this);">Show source &equiv;</a></p>
  <div id="source-lcsim.LightCurveSimulator.set_time_sampling" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">set_time_sampling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_total</span><span class="p">,</span> <span class="n">time_sampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create an instance of LightCurveSimulator.</span>
<span class="sd">    Parameters</span>
<span class="sd">    -----</span>
<span class="sd">    time_total : float</span>
<span class="sd">        Set the total time for the simulated data.</span>
<span class="sd">    time_sampling : float</span>
<span class="sd">        Set the time sampling for the simulated data.</span>
<span class="sd">    Returns</span>
<span class="sd">    -----</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">time_total</span> <span class="o">=</span> <span class="n">time_total</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">time_sampling</span> <span class="o">=</span> <span class="n">time_sampling</span>
    <span class="c1"># number of data points of the simulated data:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ndp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">time_total</span> <span class="o">/</span> <span class="n">time_sampling</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="c1"># create data time steps:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_create_timesteps</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="lcsim.LightCurveSimulator.sim_emp">
    <p>def <span class="ident">sim_emp</span>(</p><p>self, spec_shape, spec_args, pdf, pdf_params=None, pdf_range=None, nlcs=1, iterations=100, keep_non_converged=False, threshold=0.01)</p>
    </div>
    

    
  
    <div class="desc"><p>Create a simulated light curve with a specified PSD and PDF.</p>
<p>This method combines the two steps of producting a Gaussian light curve
with a given PSD [1] and adjusting its PDF to a specified PDF [2].</p>
<h2>Parameters</h2>
<p>spec_shape : func
    Function that takes an array of frequencies and 'spec_args' as
    input and calculates a spectrum for those frequencies.
spec_args : list
    Function arguments to 'spec_shape'.
pdf : numpy.ndarray or callable
    When providing flux data in a numpy.array the method will calculate
    an ECDF of the input data and draw random flux values from that
    ECDF.
    When providing a callable function the method will use that
    function to draw random flux values. Parameters for the function
    need to be provided in 'pdf_params'
pdf_params : list, default=None
    When a callable function is given to 'pdf', corresponding
    parameters need to be given to 'pdf_params'.
pdf_range : list
    List of two elements. Random flux values will be drawn from the
    given PDF between the two limits provided by 'pdf_range'. Required
    only when a callable function is given to 'pdf'. Does not have an
    effect, when a numpy.ndarray is given to 'pdf'.
nlcs : int, default=1
    Set the number of light curves that are produced. See notes below.
iterations : int, default=100
    The algorithm [1] is iterative. This value sets a maximum number of
    iterations to avoid infinite loops.
keep_non_converged : bool or str, default=False
    If True the result is returned even if the algorithm [1] did not
    converge.
    If False and the algorithm [1] did not converge, False is returned.
    If set to 'ask', a notification is written asking how to proceed.
threshold : float, default=0.01
    Defines when the algorithm [1] is considered as converged.
    Iterations are stopped when maximum difference between the current
    and the previous light curve does not exceed this 'threshold'.</p>
<h2>Returns</h2>
<p>None</p>
<h2>Notes</h2>
<p>The method will initially produce one long Gaussian light curve with a
total time N times longer than the final total time, where N is set by
'nlcs'. This long light curve is then split into N individual pieces.
Producing one initial long light curves means that power at frequencies
N times lower than the final total time is included in the noise
process. Setting ncls&gt;1 allows to include low-frequency power.
The adjustment of the PDF is then applied to every split light curve
individually.</p>
<h2>References</h2>
<p>[1] Timmer and Koenig, 1995, 'On generating power law noise', A&amp;A, 300,
    707
[2] Emmanoulopoulos et al, 2013, MNRAS, 433, 907</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-lcsim.LightCurveSimulator.sim_emp', this);">Show source &equiv;</a></p>
  <div id="source-lcsim.LightCurveSimulator.sim_emp" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">sim_emp</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">spec_shape</span><span class="p">,</span> <span class="n">spec_args</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">pdf_params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pdf_range</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
        <span class="n">nlcs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  <span class="n">iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">keep_non_converged</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a simulated light curve with a specified PSD and PDF.</span>
<span class="sd">    This method combines the two steps of producting a Gaussian light curve</span>
<span class="sd">    with a given PSD [1] and adjusting its PDF to a specified PDF [2].</span>
<span class="sd">    Parameters</span>
<span class="sd">    -----</span>
<span class="sd">    spec_shape : func</span>
<span class="sd">        Function that takes an array of frequencies and &#39;spec_args&#39; as</span>
<span class="sd">        input and calculates a spectrum for those frequencies.</span>
<span class="sd">    spec_args : list</span>
<span class="sd">        Function arguments to &#39;spec_shape&#39;.</span>
<span class="sd">    pdf : numpy.ndarray or callable</span>
<span class="sd">        When providing flux data in a numpy.array the method will calculate</span>
<span class="sd">        an ECDF of the input data and draw random flux values from that</span>
<span class="sd">        ECDF.</span>
<span class="sd">        When providing a callable function the method will use that</span>
<span class="sd">        function to draw random flux values. Parameters for the function</span>
<span class="sd">        need to be provided in &#39;pdf_params&#39;</span>
<span class="sd">    pdf_params : list, default=None</span>
<span class="sd">        When a callable function is given to &#39;pdf&#39;, corresponding</span>
<span class="sd">        parameters need to be given to &#39;pdf_params&#39;.</span>
<span class="sd">    pdf_range : list</span>
<span class="sd">        List of two elements. Random flux values will be drawn from the</span>
<span class="sd">        given PDF between the two limits provided by &#39;pdf_range&#39;. Required</span>
<span class="sd">        only when a callable function is given to &#39;pdf&#39;. Does not have an</span>
<span class="sd">        effect, when a numpy.ndarray is given to &#39;pdf&#39;.</span>
<span class="sd">    nlcs : int, default=1</span>
<span class="sd">        Set the number of light curves that are produced. See notes below.</span>
<span class="sd">    iterations : int, default=100</span>
<span class="sd">        The algorithm [1] is iterative. This value sets a maximum number of</span>
<span class="sd">        iterations to avoid infinite loops.</span>
<span class="sd">    keep_non_converged : bool or str, default=False</span>
<span class="sd">        If True the result is returned even if the algorithm [1] did not</span>
<span class="sd">        converge.</span>
<span class="sd">        If False and the algorithm [1] did not converge, False is returned.</span>
<span class="sd">        If set to &#39;ask&#39;, a notification is written asking how to proceed.</span>
<span class="sd">    threshold : float, default=0.01</span>
<span class="sd">        Defines when the algorithm [1] is considered as converged.</span>
<span class="sd">        Iterations are stopped when maximum difference between the current</span>
<span class="sd">        and the previous light curve does not exceed this &#39;threshold&#39;.</span>
<span class="sd">    Returns</span>
<span class="sd">    -----</span>
<span class="sd">    None</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The method will initially produce one long Gaussian light curve with a</span>
<span class="sd">    total time N times longer than the final total time, where N is set by</span>
<span class="sd">    &#39;nlcs&#39;. This long light curve is then split into N individual pieces.</span>
<span class="sd">    Producing one initial long light curves means that power at frequencies</span>
<span class="sd">    N times lower than the final total time is included in the noise</span>
<span class="sd">    process. Setting ncls&gt;1 allows to include low-frequency power.</span>
<span class="sd">    The adjustment of the PDF is then applied to every split light curve</span>
<span class="sd">    individually.</span>
<span class="sd">    References</span>
<span class="sd">    -----</span>
<span class="sd">    [1] Timmer and Koenig, 1995, &#39;On generating power law noise&#39;, A&amp;A, 300,</span>
<span class="sd">        707</span>
<span class="sd">    [2] Emmanoulopoulos et al, 2013, MNRAS, 433, 907</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sim_tk</span><span class="p">(</span><span class="n">spec_shape</span><span class="p">,</span> <span class="n">spec_args</span><span class="p">,</span> <span class="n">nlcs</span><span class="o">=</span><span class="n">nlcs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">adjust_pdf</span><span class="p">(</span>
            <span class="n">pdf</span><span class="p">,</span> <span class="n">pdf_params</span><span class="o">=</span><span class="n">pdf_params</span><span class="p">,</span> <span class="n">pdf_range</span><span class="o">=</span><span class="n">pdf_range</span><span class="p">,</span>
            <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span> <span class="n">keep_non_converged</span><span class="o">=</span><span class="n">keep_non_converged</span><span class="p">,</span>
            <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="lcsim.LightCurveSimulator.sim_tk">
    <p>def <span class="ident">sim_tk</span>(</p><p>self, spec_shape, spec_args, nlcs=1, seed=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Simulates one/multiple equally sampled light curve(s) following a
random noise process with given a spectral shape of the power spectral
density [1].</p>
<h2>Parameters</h2>
<p>spec_shape : func
    Function that takes an array of frequencies and 'spec_args' as
    input and calculates a spectrum for those frequencies.
spec_args : list
    Function arguments to 'spec_shape'.
nlcs : int, default=1
    Set the number of light curves that are produced. See notes below.
seed : int, default=False
    Sets a seed for the random generator to get a reproducable result.
    For testing only.</p>
<h2>Returns</h2>
<p>None</p>
<h2>Notes</h2>
<p>The method will initially produce one long light curve with a total
time N times longer than the final total time, where N is set by
'nlcs'. This long light curve is then split into N individual pieces.
Producing one initial long light curves means that power at frequencies
N times lower than the final total time is included in the noise
process. Setting ncls&gt;1 allows to include low-frequency power.</p>
<h2>References</h2>
<p>[1] Timmer and Koenig, 1995, 'On generating power law noise', A&amp;A, 300,
    707</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-lcsim.LightCurveSimulator.sim_tk', this);">Show source &equiv;</a></p>
  <div id="source-lcsim.LightCurveSimulator.sim_tk" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">sim_tk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec_shape</span><span class="p">,</span> <span class="n">spec_args</span><span class="p">,</span> <span class="n">nlcs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simulates one/multiple equally sampled light curve(s) following a</span>
<span class="sd">    random noise process with given a spectral shape of the power spectral</span>
<span class="sd">    density [1].</span>
<span class="sd">    Parameters</span>
<span class="sd">    -----</span>
<span class="sd">    spec_shape : func</span>
<span class="sd">        Function that takes an array of frequencies and &#39;spec_args&#39; as</span>
<span class="sd">        input and calculates a spectrum for those frequencies.</span>
<span class="sd">    spec_args : list</span>
<span class="sd">        Function arguments to &#39;spec_shape&#39;.</span>
<span class="sd">    nlcs : int, default=1</span>
<span class="sd">        Set the number of light curves that are produced. See notes below.</span>
<span class="sd">    seed : int, default=False</span>
<span class="sd">        Sets a seed for the random generator to get a reproducable result.</span>
<span class="sd">        For testing only.</span>
<span class="sd">    Returns</span>
<span class="sd">    -----</span>
<span class="sd">    None</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The method will initially produce one long light curve with a total</span>
<span class="sd">    time N times longer than the final total time, where N is set by</span>
<span class="sd">    &#39;nlcs&#39;. This long light curve is then split into N individual pieces.</span>
<span class="sd">    Producing one initial long light curves means that power at frequencies</span>
<span class="sd">    N times lower than the final total time is included in the noise</span>
<span class="sd">    process. Setting ncls&gt;1 allows to include low-frequency power.</span>
<span class="sd">    References</span>
<span class="sd">    -----</span>
<span class="sd">    [1] Timmer and Koenig, 1995, &#39;On generating power law noise&#39;, A&amp;A, 300,</span>
<span class="sd">        707</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get total time of long light curve:</span>
    <span class="n">time_total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_sampling</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndp</span> <span class="o">*</span> <span class="n">nlcs</span>
    <span class="c1"># simulate long lightcurve:</span>
    <span class="n">lightcurve</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sim_tk</span><span class="p">(</span>
            <span class="n">time_total</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_sampling</span><span class="p">,</span> <span class="n">spec_shape</span><span class="p">,</span> <span class="n">spec_args</span><span class="p">,</span>
            <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">lightcurve</span> <span class="o">=</span> <span class="n">lightcurve</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># one light curve: store final data:</span>
    <span class="k">if</span> <span class="n">nlcs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span> <span class="o">=</span> <span class="p">[</span><span class="n">lightcurve</span><span class="p">]</span>
    <span class="c1"># multiple light curves: reshape to short light curves:</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">nlcs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndp</span><span class="p">)</span>
        <span class="n">lightcurves</span> <span class="o">=</span> <span class="n">lightcurve</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">ndp</span><span class="o">*</span><span class="n">nlcs</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">lc</span> <span class="ow">in</span> <span class="n">lightcurves</span><span class="p">:</span>
            <span class="c1"># normalize to zero mean:</span>
            <span class="n">lc</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lightcurves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lc_type</span> <span class="o">=</span> <span class="s1">&#39;TK&#39;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lc_scale</span> <span class="o">=</span> <span class="s1">&#39;None&#39;</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
